From 28953419258f2acfa5ddffa33a3d15e3ce0c0116 Mon Sep 17 00:00:00 2001
From: MARiA so cute <33935209+NathanFreeman@users.noreply.github.com>
Date: Mon, 23 Sep 2024 17:54:27 +0800
Subject: [PATCH] [6.0] cURL supports version 8.4 (#5481)

* support php8.4 curl

* fix missing zif_swoole_exit

* remove php8.4
---
 config.m4                              |    3 +
 ext-src/php_swoole_curl.h              |    4 +
 ext-src/swoole_coroutine.cc            |    2 +
 ext-src/swoole_redis_server.cc         |   12 +
 ext-src/swoole_runtime.cc              |    5 +
 thirdparty/php/curl/curl_arginfo.h     |    2 +-
 thirdparty/php/curl/curl_interface.h   |    2 +-
 thirdparty/php/curl/curl_private.h     |    2 +-
 thirdparty/php/curl/interface.cc       |    2 +-
 thirdparty/php/curl/multi.cc           |    2 +-
 thirdparty/php/curl/php_curl.h         |    2 +-
 thirdparty/php84/curl/curl_arginfo.h   |  162 ++
 thirdparty/php84/curl/curl_interface.h |   60 +
 thirdparty/php84/curl/curl_private.h   |  167 ++
 thirdparty/php84/curl/interface.cc     | 2805 ++++++++++++++++++++++++
 thirdparty/php84/curl/multi.cc         |  636 ++++++
 thirdparty/php84/curl/php_curl.h       |   49 +
 17 files changed, 3911 insertions(+), 6 deletions(-)
 create mode 100644 thirdparty/php84/curl/curl_arginfo.h
 create mode 100644 thirdparty/php84/curl/curl_interface.h
 create mode 100644 thirdparty/php84/curl/curl_private.h
 create mode 100644 thirdparty/php84/curl/interface.cc
 create mode 100644 thirdparty/php84/curl/multi.cc
 create mode 100644 thirdparty/php84/curl/php_curl.h

diff --git a/config.m4 b/config.m4
index 554a93896b..ec78cfbcf9 100644
--- a/config.m4
+++ b/config.m4
@@ -1042,6 +1042,8 @@ EOF
     swoole_source_file="$swoole_source_file \
         thirdparty/php/curl/interface.cc \
         thirdparty/php/curl/multi.cc \
+        thirdparty/php84/curl/interface.cc \
+        thirdparty/php84/curl/multi.cc \
         thirdparty/php/sockets/multicast.cc \
         thirdparty/php/sockets/sendrecvmsg.cc \
         thirdparty/php/sockets/conversions.cc \
@@ -1259,6 +1261,7 @@ EOF
     PHP_ADD_BUILD_DIR($ext_builddir/thirdparty/php/sockets)
     PHP_ADD_BUILD_DIR($ext_builddir/thirdparty/php/standard)
     PHP_ADD_BUILD_DIR($ext_builddir/thirdparty/php/curl)
+    PHP_ADD_BUILD_DIR($ext_builddir/thirdparty/php84/curl)
     if test "$PHP_NGHTTP2_DIR" = "no"; then
         PHP_ADD_BUILD_DIR($ext_builddir/thirdparty/nghttp2)
 	fi
diff --git a/ext-src/php_swoole_curl.h b/ext-src/php_swoole_curl.h
index 4977d95b1a..1cfbe587f0 100644
--- a/ext-src/php_swoole_curl.h
+++ b/ext-src/php_swoole_curl.h
@@ -24,7 +24,11 @@
 SW_EXTERN_C_BEGIN
 #include <curl/curl.h>
 #include <curl/multi.h>
+#if PHP_VERSION_ID >= 80400
+#include "thirdparty/php84/curl/curl_private.h"
+#else
 #include "thirdparty/php/curl/curl_private.h"
+#endif
 SW_EXTERN_C_END
 
 #if LIBCURL_VERSION_NUM < 0x073800
diff --git a/ext-src/swoole_redis_server.cc b/ext-src/swoole_redis_server.cc
index 1058bce9d0..3d0cb232f0 100644
--- a/ext-src/swoole_redis_server.cc
+++ b/ext-src/swoole_redis_server.cc
@@ -156,7 +156,11 @@ int php_swoole_redis_server_onReceive(Server *serv, RecvData *req) {
 
     char _command[SW_REDIS_MAX_COMMAND_SIZE];
     size_t _command_len = sw_snprintf(_command, sizeof(_command), "_handler_%.*s", command_len, command);
+#if PHP_VERSION_ID >= 80400
+    zend_str_tolower(_command, _command_len);
+#else
     php_strtolower(_command, _command_len);
+#endif
 
     auto i = redis_handlers.find(std::string(_command, _command_len));
     if (i == redis_handlers.end()) {
@@ -215,7 +219,11 @@ static PHP_METHOD(swoole_redis_server, setHandler) {
 
     char _command[SW_REDIS_MAX_COMMAND_SIZE];
     size_t _command_len = sw_snprintf(_command, sizeof(_command), "_handler_%s", command);
+#if PHP_VERSION_ID >= 80400
+    zend_str_tolower(_command, _command_len);
+#else
     php_strtolower(_command, _command_len);
+#endif
 
     zend_update_property(swoole_redis_server_ce, SW_Z8_OBJ_P(ZEND_THIS), _command, _command_len, zcallback);
 
@@ -241,7 +249,11 @@ static PHP_METHOD(swoole_redis_server, getHandler) {
 
     char _command[SW_REDIS_MAX_COMMAND_SIZE];
     size_t _command_len = sw_snprintf(_command, sizeof(_command), "_handler_%s", command);
+#if PHP_VERSION_ID >= 80400
+    zend_str_tolower(_command, _command_len);
+#else
     php_strtolower(_command, _command_len);
+#endif
 
     zval rv;
     zval *handler = zend_read_property(swoole_redis_server_ce, SW_Z8_OBJ_P(ZEND_THIS), _command, _command_len, 1, &rv);
diff --git a/ext-src/swoole_runtime.cc b/ext-src/swoole_runtime.cc
index b82f46937a..17fea258a6 100644
--- a/ext-src/swoole_runtime.cc
+++ b/ext-src/swoole_runtime.cc
@@ -19,9 +19,14 @@
 #include "swoole_util.h"
 
 #include "thirdparty/php/standard/proc_open.h"
+
 #ifdef SW_USE_CURL
+#if PHP_VERSION_ID >= 80400
+#include "thirdparty/php84/curl/curl_interface.h"
+#else
 #include "thirdparty/php/curl/curl_interface.h"
 #endif
+#endif
 
 #include <unordered_map>
 
diff --git a/thirdparty/php/curl/curl_arginfo.h b/thirdparty/php/curl/curl_arginfo.h
index 383716f081..2fba38648d 100644
--- a/thirdparty/php/curl/curl_arginfo.h
+++ b/thirdparty/php/curl/curl_arginfo.h
@@ -3,7 +3,7 @@
 
 #include "curl_interface.h"
 
-#ifdef SW_USE_CURL
+#if defined(SW_USE_CURL) && PHP_VERSION_ID < 80400
 
 ZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_swoole_native_curl_close, 0, 1, IS_VOID, 0)
 	ZEND_ARG_OBJ_INFO(0, handle, CurlHandle, 0)
diff --git a/thirdparty/php/curl/curl_interface.h b/thirdparty/php/curl/curl_interface.h
index cdfcf44aeb..f65e86f996 100644
--- a/thirdparty/php/curl/curl_interface.h
+++ b/thirdparty/php/curl/curl_interface.h
@@ -2,7 +2,7 @@
 
 #include "php_swoole_cxx.h"
 
-#ifdef SW_USE_CURL
+#if defined(SW_USE_CURL) && PHP_VERSION_ID < 80400
 SW_EXTERN_C_BEGIN
 
 #include <curl/curl.h>
diff --git a/thirdparty/php/curl/curl_private.h b/thirdparty/php/curl/curl_private.h
index b8be8932b5..c2a393961a 100644
--- a/thirdparty/php/curl/curl_private.h
+++ b/thirdparty/php/curl/curl_private.h
@@ -17,7 +17,7 @@
 
 /* Copied from PHP-4f68662f5b61aecf90f6d8005976f5f91d4ce8d3 */
 
-#ifdef SW_USE_CURL
+#if defined(SW_USE_CURL) && PHP_VERSION_ID < 80400
 
 #ifndef _PHP_CURL_PRIVATE_H
 #define _PHP_CURL_PRIVATE_H
diff --git a/thirdparty/php/curl/interface.cc b/thirdparty/php/curl/interface.cc
index a70a63ee3a..bffc185946 100644
--- a/thirdparty/php/curl/interface.cc
+++ b/thirdparty/php/curl/interface.cc
@@ -19,7 +19,7 @@
 
 #include "php_swoole_cxx.h"
 
-#ifdef SW_USE_CURL
+#if defined(SW_USE_CURL) && PHP_VERSION_ID < 80400
 #include "php_swoole_curl.h"
 
 using namespace swoole;
diff --git a/thirdparty/php/curl/multi.cc b/thirdparty/php/curl/multi.cc
index 52f6ccb693..abf997c0b9 100644
--- a/thirdparty/php/curl/multi.cc
+++ b/thirdparty/php/curl/multi.cc
@@ -17,7 +17,7 @@
 #include "php_swoole_cxx.h"
 #include "zend_object_handlers.h"
 
-#ifdef SW_USE_CURL
+#if defined(SW_USE_CURL) && PHP_VERSION_ID < 80400
 #include "php_swoole_curl.h"
 
 using swoole::curl::Multi;
diff --git a/thirdparty/php/curl/php_curl.h b/thirdparty/php/curl/php_curl.h
index 046f6b7922..2075384155 100644
--- a/thirdparty/php/curl/php_curl.h
+++ b/thirdparty/php/curl/php_curl.h
@@ -19,7 +19,7 @@
 
 /* Copied from PHP-7.4.11 */
 
-#ifdef SW_USE_CURL
+#if defined(SW_USE_CURL) && PHP_VERSION_ID < 80400
 
 #ifndef _PHP_CURL_H
 #define _PHP_CURL_H
diff --git a/thirdparty/php84/curl/curl_arginfo.h b/thirdparty/php84/curl/curl_arginfo.h
new file mode 100644
index 0000000000..956c405c65
--- /dev/null
+++ b/thirdparty/php84/curl/curl_arginfo.h
@@ -0,0 +1,162 @@
+/* This is a generated file, edit the .stub.php file instead.
+ * Stub hash: ddfcdd8a0bf0ee6c338ec1689c6de5d7fd87303d */
+#include "curl_interface.h"
+
+#if defined(SW_USE_CURL) && PHP_VERSION_ID >= 80400
+ZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_swoole_native_curl_close, 0, 1, IS_VOID, 0)
+	ZEND_ARG_OBJ_INFO(0, handle, CurlHandle, 0)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_swoole_native_curl_copy_handle, 0, 1, CurlHandle, MAY_BE_FALSE)
+	ZEND_ARG_OBJ_INFO(0, handle, CurlHandle, 0)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_swoole_native_curl_errno, 0, 1, IS_LONG, 0)
+	ZEND_ARG_OBJ_INFO(0, handle, CurlHandle, 0)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_swoole_native_curl_error, 0, 1, IS_STRING, 0)
+	ZEND_ARG_OBJ_INFO(0, handle, CurlHandle, 0)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_WITH_RETURN_TYPE_MASK_EX(arginfo_swoole_native_curl_escape, 0, 2, MAY_BE_STRING|MAY_BE_FALSE)
+	ZEND_ARG_OBJ_INFO(0, handle, CurlHandle, 0)
+	ZEND_ARG_TYPE_INFO(0, string, IS_STRING, 0)
+ZEND_END_ARG_INFO()
+
+#define arginfo_swoole_native_curl_unescape arginfo_swoole_native_curl_escape
+
+ZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_swoole_native_curl_multi_setopt, 0, 3, _IS_BOOL, 0)
+	ZEND_ARG_OBJ_INFO(0, multi_handle, CurlMultiHandle, 0)
+	ZEND_ARG_TYPE_INFO(0, option, IS_LONG, 0)
+	ZEND_ARG_TYPE_INFO(0, value, IS_MIXED, 0)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_WITH_RETURN_TYPE_MASK_EX(arginfo_swoole_native_curl_exec, 0, 1, MAY_BE_STRING|MAY_BE_BOOL)
+	ZEND_ARG_OBJ_INFO(0, handle, CurlHandle, 0)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_swoole_native_curl_getinfo, 0, 1, IS_MIXED, 0)
+	ZEND_ARG_OBJ_INFO(0, handle, CurlHandle, 0)
+	ZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, option, IS_LONG, 1, "null")
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_WITH_RETURN_OBJ_TYPE_MASK_EX(arginfo_swoole_native_curl_init, 0, 0, CurlHandle, MAY_BE_FALSE)
+	ZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, url, IS_STRING, 1, "null")
+ZEND_END_ARG_INFO()
+
+#if LIBCURL_VERSION_NUM >= 0x073E00 /* Available since 7.62.0 */
+ZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_swoole_native_curl_upkeep, 0, 1, _IS_BOOL, 0)
+	ZEND_ARG_OBJ_INFO(0, handle, CurlHandle, 0)
+ZEND_END_ARG_INFO()
+#endif
+
+ZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_swoole_native_curl_multi_add_handle, 0, 2, IS_LONG, 0)
+	ZEND_ARG_OBJ_INFO(0, multi_handle, CurlMultiHandle, 0)
+	ZEND_ARG_OBJ_INFO(0, handle, CurlHandle, 0)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_swoole_native_curl_multi_close, 0, 1, IS_VOID, 0)
+	ZEND_ARG_OBJ_INFO(0, multi_handle, CurlMultiHandle, 0)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_swoole_native_curl_multi_errno, 0, 1, IS_LONG, 0)
+	ZEND_ARG_OBJ_INFO(0, multi_handle, CurlMultiHandle, 0)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_swoole_native_curl_multi_exec, 0, 2, IS_LONG, 0)
+	ZEND_ARG_OBJ_INFO(0, multi_handle, CurlMultiHandle, 0)
+	ZEND_ARG_INFO(1, still_running)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_swoole_native_curl_multi_getcontent, 0, 1, IS_STRING, 1)
+	ZEND_ARG_OBJ_INFO(0, handle, CurlHandle, 0)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_WITH_RETURN_TYPE_MASK_EX(arginfo_swoole_native_curl_multi_info_read, 0, 1, MAY_BE_ARRAY|MAY_BE_FALSE)
+	ZEND_ARG_OBJ_INFO(0, multi_handle, CurlMultiHandle, 0)
+	ZEND_ARG_INFO_WITH_DEFAULT_VALUE(1, queued_messages, "null")
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_WITH_RETURN_OBJ_INFO_EX(arginfo_swoole_native_curl_multi_init, 0, 0, CurlMultiHandle, 0)
+ZEND_END_ARG_INFO()
+
+#define arginfo_swoole_native_curl_multi_remove_handle arginfo_swoole_native_curl_multi_add_handle
+
+ZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_swoole_native_curl_multi_select, 0, 1, IS_LONG, 0)
+	ZEND_ARG_OBJ_INFO(0, multi_handle, CurlMultiHandle, 0)
+	ZEND_ARG_TYPE_INFO_WITH_DEFAULT_VALUE(0, timeout, IS_DOUBLE, 0, "1.0")
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_swoole_native_curl_multi_strerror, 0, 1, IS_STRING, 1)
+	ZEND_ARG_TYPE_INFO(0, error_code, IS_LONG, 0)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_swoole_native_curl_pause, 0, 2, IS_LONG, 0)
+	ZEND_ARG_OBJ_INFO(0, handle, CurlHandle, 0)
+	ZEND_ARG_TYPE_INFO(0, flags, IS_LONG, 0)
+ZEND_END_ARG_INFO()
+
+#define arginfo_swoole_native_curl_reset arginfo_swoole_native_curl_close
+
+ZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_swoole_native_curl_setopt_array, 0, 2, _IS_BOOL, 0)
+	ZEND_ARG_OBJ_INFO(0, handle, CurlHandle, 0)
+	ZEND_ARG_TYPE_INFO(0, options, IS_ARRAY, 0)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_WITH_RETURN_TYPE_INFO_EX(arginfo_swoole_native_curl_setopt, 0, 3, _IS_BOOL, 0)
+	ZEND_ARG_OBJ_INFO(0, handle, CurlHandle, 0)
+	ZEND_ARG_TYPE_INFO(0, option, IS_LONG, 0)
+	ZEND_ARG_TYPE_INFO(0, value, IS_MIXED, 0)
+ZEND_END_ARG_INFO()
+
+#define arginfo_swoole_native_curl_strerror arginfo_swoole_native_curl_multi_strerror
+
+ZEND_BEGIN_ARG_WITH_RETURN_TYPE_MASK_EX(arginfo_swoole_native_curl_version, 0, 0, MAY_BE_ARRAY|MAY_BE_FALSE)
+ZEND_END_ARG_INFO()
+
+static const zend_function_entry swoole_native_curl_functions[] = {
+	ZEND_FE(swoole_native_curl_close, arginfo_swoole_native_curl_close)
+	ZEND_FE(swoole_native_curl_copy_handle, arginfo_swoole_native_curl_copy_handle)
+	ZEND_FE(swoole_native_curl_errno, arginfo_swoole_native_curl_errno)
+	ZEND_FE(swoole_native_curl_error, arginfo_swoole_native_curl_error)
+	ZEND_FE(swoole_native_curl_escape, arginfo_swoole_native_curl_escape)
+	ZEND_FE(swoole_native_curl_unescape, arginfo_swoole_native_curl_unescape)
+	ZEND_FE(swoole_native_curl_multi_setopt, arginfo_swoole_native_curl_multi_setopt)
+	ZEND_FE(swoole_native_curl_exec, arginfo_swoole_native_curl_exec)
+	ZEND_FE(swoole_native_curl_getinfo, arginfo_swoole_native_curl_getinfo)
+	ZEND_FE(swoole_native_curl_init, arginfo_swoole_native_curl_init)
+#if LIBCURL_VERSION_NUM >= 0x073E00 /* Available since 7.62.0 */
+	ZEND_FE(swoole_native_curl_upkeep, arginfo_swoole_native_curl_upkeep)
+#endif
+	ZEND_FE(swoole_native_curl_multi_add_handle, arginfo_swoole_native_curl_multi_add_handle)
+	ZEND_FE(swoole_native_curl_multi_close, arginfo_swoole_native_curl_multi_close)
+	ZEND_FE(swoole_native_curl_multi_errno, arginfo_swoole_native_curl_multi_errno)
+	ZEND_FE(swoole_native_curl_multi_exec, arginfo_swoole_native_curl_multi_exec)
+	ZEND_FE(swoole_native_curl_multi_getcontent, arginfo_swoole_native_curl_multi_getcontent)
+	ZEND_FE(swoole_native_curl_multi_info_read, arginfo_swoole_native_curl_multi_info_read)
+	ZEND_FE(swoole_native_curl_multi_init, arginfo_swoole_native_curl_multi_init)
+	ZEND_FE(swoole_native_curl_multi_remove_handle, arginfo_swoole_native_curl_multi_remove_handle)
+	ZEND_FE(swoole_native_curl_multi_select, arginfo_swoole_native_curl_multi_select)
+	ZEND_FE(swoole_native_curl_multi_strerror, arginfo_swoole_native_curl_multi_strerror)
+	ZEND_FE(swoole_native_curl_pause, arginfo_swoole_native_curl_pause)
+	ZEND_FE(swoole_native_curl_reset, arginfo_swoole_native_curl_reset)
+	ZEND_FE(swoole_native_curl_setopt_array, arginfo_swoole_native_curl_setopt_array)
+	ZEND_FE(swoole_native_curl_setopt, arginfo_swoole_native_curl_setopt)
+	ZEND_FE(swoole_native_curl_strerror, arginfo_swoole_native_curl_strerror)
+	ZEND_FE(swoole_native_curl_version, arginfo_swoole_native_curl_version)
+	ZEND_FE_END
+};
+
+static const zend_function_entry class_CurlHandle_methods[] = {
+	ZEND_FE_END
+};
+
+static const zend_function_entry class_CurlMultiHandle_methods[] = {
+	ZEND_FE_END
+};
+
+static const zend_function_entry class_CurlShareHandle_methods[] = {
+	ZEND_FE_END
+};
+#endif
diff --git a/thirdparty/php84/curl/curl_interface.h b/thirdparty/php84/curl/curl_interface.h
new file mode 100644
index 0000000000..11d9f1ef17
--- /dev/null
+++ b/thirdparty/php84/curl/curl_interface.h
@@ -0,0 +1,60 @@
+/*
+  +----------------------------------------------------------------------+
+  | Swoole                                                               |
+  +----------------------------------------------------------------------+
+  | Copyright (c) 2012-2018 The Swoole Group                             |
+  +----------------------------------------------------------------------+
+  | This source file is subject to version 2.0 of the Apache license,    |
+  | that is bundled with this package in the file LICENSE, and is        |
+  | available through the world-wide-web at the following url:           |
+  | http://www.apache.org/licenses/LICENSE-2.0.html                      |
+  | If you did not receive a copy of the Apache2.0 license and are unable|
+  | to obtain it through the world-wide-web, please send a note to       |
+  | license@swoole.com so we can mail you a copy immediately.            |
+  +----------------------------------------------------------------------+
+  | Author: NathanFreeman  <mariasocute@163.com>                         |
+  +----------------------------------------------------------------------+
+*/
+#pragma once
+
+#include "php_swoole_cxx.h"
+#if defined(SW_USE_CURL) && PHP_VERSION_ID >= 80400
+SW_EXTERN_C_BEGIN
+
+#include <curl/curl.h>
+#include <curl/multi.h>
+
+void swoole_native_curl_minit(int module_number);
+void swoole_native_curl_mshutdown();
+
+ZEND_FUNCTION(swoole_native_curl_close);
+ZEND_FUNCTION(swoole_native_curl_copy_handle);
+ZEND_FUNCTION(swoole_native_curl_errno);
+ZEND_FUNCTION(swoole_native_curl_error);
+ZEND_FUNCTION(swoole_native_curl_escape);
+ZEND_FUNCTION(swoole_native_curl_unescape);
+ZEND_FUNCTION(swoole_native_curl_multi_setopt);
+ZEND_FUNCTION(swoole_native_curl_exec);
+ZEND_FUNCTION(swoole_native_curl_getinfo);
+ZEND_FUNCTION(swoole_native_curl_init);
+#if LIBCURL_VERSION_NUM >= 0x073E00 /* Available since 7.62.0 */
+ZEND_FUNCTION(swoole_native_curl_upkeep);
+#endif
+ZEND_FUNCTION(swoole_native_curl_multi_add_handle);
+ZEND_FUNCTION(swoole_native_curl_multi_close);
+ZEND_FUNCTION(swoole_native_curl_multi_errno);
+ZEND_FUNCTION(swoole_native_curl_multi_exec);
+ZEND_FUNCTION(swoole_native_curl_multi_getcontent);
+ZEND_FUNCTION(swoole_native_curl_multi_info_read);
+ZEND_FUNCTION(swoole_native_curl_multi_init);
+ZEND_FUNCTION(swoole_native_curl_multi_remove_handle);
+ZEND_FUNCTION(swoole_native_curl_multi_select);
+ZEND_FUNCTION(swoole_native_curl_multi_strerror);
+ZEND_FUNCTION(swoole_native_curl_pause);
+ZEND_FUNCTION(swoole_native_curl_reset);
+ZEND_FUNCTION(swoole_native_curl_setopt_array);
+ZEND_FUNCTION(swoole_native_curl_setopt);
+ZEND_FUNCTION(swoole_native_curl_strerror);
+ZEND_FUNCTION(swoole_native_curl_version);
+SW_EXTERN_C_END
+#endif
diff --git a/thirdparty/php84/curl/curl_private.h b/thirdparty/php84/curl/curl_private.h
new file mode 100644
index 0000000000..4890ed1df2
--- /dev/null
+++ b/thirdparty/php84/curl/curl_private.h
@@ -0,0 +1,167 @@
+/*
+   +----------------------------------------------------------------------+
+   | Copyright (c) The PHP Group                                          |
+   +----------------------------------------------------------------------+
+   | This source file is subject to version 3.01 of the PHP license,      |
+   | that is bundled with this package in the file LICENSE, and is        |
+   | available through the world-wide-web at the following url:           |
+   | https://www.php.net/license/3_01.txt                                 |
+   | If you did not receive a copy of the PHP license and are unable to   |
+   | obtain it through the world-wide-web, please send a note to          |
+   | license@php.net so we can mail you a copy immediately.               |
+   +----------------------------------------------------------------------+
+   | Author: Sterling Hughes <sterling@php.net>                           |
+   |         Wez Furlong <wez@thebrainroom.com>                           |
+   +----------------------------------------------------------------------+
+*/
+
+#if defined(SW_USE_CURL) && PHP_VERSION_ID >= 80400
+
+#ifndef _PHP_CURL_PRIVATE_H
+#define _PHP_CURL_PRIVATE_H
+
+#include "php_curl.h"
+
+#define PHP_CURL_DEBUG 0
+
+#include "php_version.h"
+#define PHP_CURL_VERSION PHP_VERSION
+
+#include <curl/curl.h>
+#include <curl/multi.h>
+
+#define CURLOPT_RETURNTRANSFER 19913
+#define CURLOPT_BINARYTRANSFER 19914 /* For Backward compatibility */
+#define PHP_CURL_STDOUT 0
+#define PHP_CURL_FILE 1
+#define PHP_CURL_USER 2
+#define PHP_CURL_DIRECT 3
+#define PHP_CURL_RETURN 4
+#define PHP_CURL_IGNORE 7
+
+#define SAVE_CURL_ERROR(__handle, __err)                                                                               \
+    do {                                                                                                               \
+        (__handle)->err.no = (int) __err;                                                                              \
+    } while (0)
+
+PHP_MINIT_FUNCTION(curl);
+PHP_MSHUTDOWN_FUNCTION(curl);
+PHP_MINFO_FUNCTION(curl);
+
+typedef struct {
+    zend_fcall_info_cache fcc;
+    FILE *fp;
+    smart_str buf;
+    int method;
+    zval stream;
+} php_curl_write;
+
+typedef struct {
+    zend_fcall_info_cache fcc;
+    FILE *fp;
+    zend_resource *res;
+    int method;
+    zval stream;
+} php_curl_read;
+
+typedef struct {
+    php_curl_write *write;
+    php_curl_write *write_header;
+    php_curl_read *read;
+    zval std_err;
+    zend_fcall_info_cache progress;
+    zend_fcall_info_cache xferinfo;
+    zend_fcall_info_cache fnmatch;
+#if LIBCURL_VERSION_NUM >= 0x075400 /* Available since 7.84.0 */
+    zend_fcall_info_cache sshhostkey;
+#endif
+} php_curl_handlers;
+
+struct _php_curl_error {
+    char str[CURL_ERROR_SIZE + 1];
+    int no;
+};
+
+struct _php_curl_send_headers {
+    zend_string *str;
+};
+
+struct _php_curl_free {
+    zend_llist post;
+    zend_llist stream;
+    HashTable *slist;
+};
+
+typedef struct {
+    CURL *cp;
+    php_curl_handlers handlers;
+    struct _php_curl_free *to_free;
+    struct _php_curl_send_headers header;
+    struct _php_curl_error err;
+    bool in_callback;
+    uint32_t *clone;
+    zval postfields;
+    /* For CURLOPT_PRIVATE */
+    zval private_data;
+    /* CurlShareHandle object set using CURLOPT_SHARE. */
+    struct _php_curlsh *share;
+    zend_object std;
+} php_curl;
+
+#define CURLOPT_SAFE_UPLOAD -1
+
+typedef struct {
+    zend_fcall_info_cache server_push;
+} php_curlm_handlers;
+
+namespace swoole {
+namespace curl {
+class Multi;
+}
+}  // namespace swoole
+
+using swoole::curl::Multi;
+
+typedef struct {
+    Multi *multi;
+    zend_llist easyh;
+    php_curlm_handlers handlers;
+    struct {
+        int no;
+    } err;
+    zend_object std;
+} php_curlm;
+
+typedef struct _php_curlsh {
+    CURLSH *share;
+    struct {
+        int no;
+    } err;
+    zend_object std;
+} php_curlsh;
+
+php_curl *swoole_curl_init_handle_into_zval(zval *curl);
+void swoole_curl_init_handle(php_curl *ch);
+void swoole_curl_cleanup_handle(php_curl *);
+void swoole_curl_multi_cleanup_list(void *data);
+void swoole_curl_verify_handlers(php_curl *ch, bool reporterror);
+void swoole_setup_easy_copy_handlers(php_curl *ch, php_curl *source);
+
+static inline php_curl *curl_from_obj(zend_object *obj) {
+    return (php_curl *) ((char *) (obj) -XtOffsetOf(php_curl, std));
+}
+
+#define Z_CURL_P(zv) curl_from_obj(Z_OBJ_P(zv))
+
+static inline php_curlsh *curl_share_from_obj(zend_object *obj) {
+    return (php_curlsh *) ((char *) (obj) -XtOffsetOf(php_curlsh, std));
+}
+
+#define Z_CURL_SHARE_P(zv) curl_share_from_obj(Z_OBJ_P(zv))
+void curl_multi_register_class(const zend_function_entry *method_entries);
+zend_result swoole_curl_cast_object(zend_object *obj, zval *result, int type);
+
+php_curl *swoole_curl_get_handle(zval *zid, bool exclusive = true, bool required = true);
+
+#endif /* _PHP_CURL_PRIVATE_H */
+#endif
diff --git a/thirdparty/php84/curl/interface.cc b/thirdparty/php84/curl/interface.cc
new file mode 100644
index 0000000000..4f363eec14
--- /dev/null
+++ b/thirdparty/php84/curl/interface.cc
@@ -0,0 +1,2805 @@
+/*
+   +----------------------------------------------------------------------+
+   | Copyright (c) The PHP Group                                          |
+   +----------------------------------------------------------------------+
+   | This source file is subject to version 3.01 of the PHP license,      |
+   | that is bundled with this package in the file LICENSE, and is        |
+   | available through the world-wide-web at the following url:           |
+   | https://www.php.net/license/3_01.txt                                 |
+   | If you did not receive a copy of the PHP license and are unable to   |
+   | obtain it through the world-wide-web, please send a note to          |
+   | license@php.net so we can mail you a copy immediately.               |
+   +----------------------------------------------------------------------+
+   | Author: Sterling Hughes <sterling@php.net>                           |
+   +----------------------------------------------------------------------+
+*/
+
+#include "php_swoole_cxx.h"
+
+#if defined(SW_USE_CURL) && PHP_VERSION_ID >= 80400
+#include "php_swoole_curl.h"
+using namespace swoole;
+
+SW_EXTERN_C_BEGIN
+#define ZEND_INCLUDE_FULL_WINDOWS_HEADERS
+#include "curl_interface.h"
+#include "curl_arginfo.h"
+
+#include <stdio.h>
+#include <string.h>
+
+#ifdef PHP_WIN32
+#include <winsock2.h>
+#include <sys/types.h>
+#endif
+
+#include <curl/curl.h>
+#include <curl/easy.h>
+
+/* As of curl 7.11.1 this is no longer defined inside curl.h */
+#ifndef HttpPost
+#define HttpPost curl_httppost
+#endif
+
+/* {{{ cruft for thread safe SSL crypto locks */
+#if defined(ZTS) && defined(HAVE_CURL_OLD_OPENSSL)
+#if defined(HAVE_OPENSSL_CRYPTO_H)
+#define PHP_CURL_NEED_OPENSSL_TSL
+#include <openssl/crypto.h>
+#else
+#warning "libcurl was compiled with OpenSSL support, but configure could not find " \
+	"openssl/crypto.h; thus no SSL crypto locking callbacks will be set, which may " \
+	"cause random crashes on SSL requests"
+#endif
+#endif /* ZTS && HAVE_CURL_OLD_OPENSSL */
+/* }}} */
+
+#include "zend_smart_str.h"
+#include "ext/standard/info.h"
+#include "ext/standard/file.h"
+#include "ext/standard/url.h"
+#include "curl_private.h"
+
+#ifdef __GNUC__
+/* don't complain about deprecated CURLOPT_* we're exposing to PHP; we
+   need to keep using those to avoid breaking PHP API compatibiltiy */
+#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
+#endif
+
+#ifdef PHP_CURL_NEED_OPENSSL_TSL /* {{{ */
+static MUTEX_T *php_curl_openssl_tsl = NULL;
+
+/* Locking callbacks are no longer used since OpenSSL 1.1. Mark the functions as unused to
+ * avoid warnings due to this. */
+static ZEND_ATTRIBUTE_UNUSED void php_curl_ssl_lock(int mode, int n, const char *file, int line) {
+    if (mode & CRYPTO_LOCK) {
+        tsrm_mutex_lock(php_curl_openssl_tsl[n]);
+    } else {
+        tsrm_mutex_unlock(php_curl_openssl_tsl[n]);
+    }
+}
+
+static ZEND_ATTRIBUTE_UNUSED unsigned long php_curl_ssl_id(void) {
+    return (unsigned long) tsrm_thread_id();
+}
+#endif
+/* }}} */
+
+static zend_class_entry *swoole_native_curl_exception_ce;
+static zend_object_handlers swoole_native_curl_exception_handlers;
+
+#define CAAL(s, v) add_assoc_long_ex(return_value, s, sizeof(s) - 1, (zend_long) v);
+#define CAAD(s, v) add_assoc_double_ex(return_value, s, sizeof(s) - 1, (double) v);
+#define CAAS(s, v) add_assoc_string_ex(return_value, s, sizeof(s) - 1, (char *) (v ? v : ""));
+#define CAASTR(s, v) add_assoc_str_ex(return_value, s, sizeof(s) - 1, v ? zend_string_copy(v) : ZSTR_EMPTY_ALLOC());
+#define CAAZ(s, v) add_assoc_zval_ex(return_value, s, sizeof(s) - 1, (zval *) v);
+
+#if defined(PHP_WIN32) || defined(__GNUC__)
+#define php_curl_ret(__ret)                                                                                            \
+    RETVAL_FALSE;                                                                                                      \
+    return __ret;
+#else
+#define php_curl_ret(__ret)                                                                                            \
+    RETVAL_FALSE;                                                                                                      \
+    return;
+#endif
+
+php_curl *swoole_curl_get_handle(zval *zid, bool exclusive, bool required) {
+    php_curl *ch = Z_CURL_P(zid);
+    if (SWOOLE_G(req_status) == PHP_SWOOLE_RSHUTDOWN_END) {
+        exclusive = false;
+    }
+    if (exclusive && swoole_coroutine_is_in()) {
+        auto handle = swoole::curl::get_handle(ch->cp);
+        if (handle && handle->multi && handle->multi->check_bound_co() == nullptr) {
+            return nullptr;
+        }
+    }
+    return ch;
+}
+
+static zend_result php_curl_option_str(php_curl *ch, zend_long option, const char *str, const size_t len) {
+    if (zend_char_has_nul_byte(str, len)) {
+        zend_value_error("%s(): cURL option must not contain any null bytes", get_active_function_name());
+        return FAILURE;
+    }
+
+    CURLcode error = curl_easy_setopt(ch->cp, (CURLoption) option, str);
+    SAVE_CURL_ERROR(ch, error);
+
+    return error == CURLE_OK ? SUCCESS : FAILURE;
+}
+
+static zend_result php_curl_option_url(php_curl *ch, const zend_string *url) /* {{{ */
+{
+    /* Disable file:// if open_basedir are used */
+    if (PG(open_basedir) && *PG(open_basedir)) {
+        curl_easy_setopt(ch->cp, CURLOPT_PROTOCOLS, CURLPROTO_ALL & ~CURLPROTO_FILE);
+    }
+
+#ifdef PHP_WIN32
+    if (zend_string_starts_with_literal_ci(url, "file://") && '/' != ZSTR_VAL(url)[sizeof("file://") - 1] &&
+        ZSTR_LEN(url) < MAXPATHLEN - 2) {
+        char _tmp[MAXPATHLEN] = {0};
+
+        memmove(_tmp, "file:///", sizeof("file:///") - 1);
+        memmove(_tmp + sizeof("file:///") - 1,
+                ZSTR_VAL(url) + sizeof("file://") - 1,
+                ZSTR_LEN(url) - sizeof("file://") + 1);
+
+        return php_curl_option_str(ch, CURLOPT_URL, _tmp, ZSTR_LEN(url) + 1);
+    }
+#endif
+
+    return php_curl_option_str(ch, CURLOPT_URL, ZSTR_VAL(url), ZSTR_LEN(url));
+}
+/* }}} */
+
+void swoole_curl_verify_handlers(php_curl *ch, bool reporterror) /* {{{ */
+{
+    php_stream *stream;
+
+    ZEND_ASSERT(ch);
+
+    if (!Z_ISUNDEF(ch->handlers.std_err)) {
+        stream = (php_stream *) zend_fetch_resource2_ex(
+            &ch->handlers.std_err, NULL, php_file_le_stream(), php_file_le_pstream());
+        if (stream == NULL) {
+            if (reporterror) {
+                php_error_docref(NULL, E_WARNING, "CURLOPT_STDERR resource has gone away, resetting to stderr");
+            }
+            zval_ptr_dtor(&ch->handlers.std_err);
+            ZVAL_UNDEF(&ch->handlers.std_err);
+
+            curl_easy_setopt(ch->cp, CURLOPT_STDERR, stderr);
+        }
+    }
+    if (ch->handlers.read && !Z_ISUNDEF(ch->handlers.read->stream)) {
+        stream = (php_stream *) zend_fetch_resource2_ex(
+            &ch->handlers.read->stream, NULL, php_file_le_stream(), php_file_le_pstream());
+        if (stream == NULL) {
+            if (reporterror) {
+                php_error_docref(NULL, E_WARNING, "CURLOPT_INFILE resource has gone away, resetting to default");
+            }
+            zval_ptr_dtor(&ch->handlers.read->stream);
+            ZVAL_UNDEF(&ch->handlers.read->stream);
+            ch->handlers.read->res = NULL;
+            ch->handlers.read->fp = 0;
+
+            curl_easy_setopt(ch->cp, CURLOPT_INFILE, (void *) ch);
+        }
+    }
+    if (ch->handlers.write_header && !Z_ISUNDEF(ch->handlers.write_header->stream)) {
+        stream = (php_stream *) zend_fetch_resource2_ex(
+            &ch->handlers.write_header->stream, NULL, php_file_le_stream(), php_file_le_pstream());
+        if (stream == NULL) {
+            if (reporterror) {
+                php_error_docref(NULL, E_WARNING, "CURLOPT_WRITEHEADER resource has gone away, resetting to default");
+            }
+            zval_ptr_dtor(&ch->handlers.write_header->stream);
+            ZVAL_UNDEF(&ch->handlers.write_header->stream);
+            ch->handlers.write_header->fp = 0;
+
+            ch->handlers.write_header->method = PHP_CURL_IGNORE;
+            curl_easy_setopt(ch->cp, CURLOPT_WRITEHEADER, (void *) ch);
+        }
+    }
+    if (ch->handlers.write && !Z_ISUNDEF(ch->handlers.write->stream)) {
+        stream = (php_stream *) zend_fetch_resource2_ex(
+            &ch->handlers.write->stream, NULL, php_file_le_stream(), php_file_le_pstream());
+        if (stream == NULL) {
+            if (reporterror) {
+                php_error_docref(NULL, E_WARNING, "CURLOPT_FILE resource has gone away, resetting to default");
+            }
+            zval_ptr_dtor(&ch->handlers.write->stream);
+            ZVAL_UNDEF(&ch->handlers.write->stream);
+            ch->handlers.write->fp = 0;
+
+            ch->handlers.write->method = PHP_CURL_STDOUT;
+            curl_easy_setopt(ch->cp, CURLOPT_FILE, (void *) ch);
+        }
+    }
+    return;
+}
+/* }}} */
+
+/* CurlHandle class */
+static const zend_function_entry swoole_coroutine_curl_handle_methods[] = {ZEND_FE_END};
+
+zend_class_entry *swoole_coroutine_curl_handle_ce;
+static zend_object_handlers swoole_coroutine_curl_handle_handlers;
+
+static zend_object *swoole_curl_create_object(zend_class_entry *class_type);
+static void swoole_curl_free_obj(zend_object *object);
+static HashTable *swoole_curl_get_gc(zend_object *object, zval **table, int *n);
+static zend_function *swoole_curl_get_constructor(zend_object *object);
+static zend_object *swoole_curl_clone_obj(zend_object *object);
+static inline zend_result build_mime_structure_from_hash(php_curl *ch, zval *zpostfields);
+SW_EXTERN_C_END
+
+void swoole_native_curl_minit(int module_number) {
+    if (!SWOOLE_G(cli)) {
+        return;
+    }
+
+#ifdef PHP_CURL_NEED_OPENSSL_TSL
+    if (!CRYPTO_get_id_callback()) {
+        int i, c = CRYPTO_num_locks();
+
+        php_curl_openssl_tsl = malloc(c * sizeof(MUTEX_T));
+        if (!php_curl_openssl_tsl) {
+            return;
+        }
+
+        for (i = 0; i < c; ++i) {
+            php_curl_openssl_tsl[i] = tsrm_mutex_alloc();
+        }
+
+        CRYPTO_set_id_callback(php_curl_ssl_id);
+        CRYPTO_set_locking_callback(php_curl_ssl_lock);
+    }
+#endif
+
+    swoole_coroutine_curl_handle_ce = curl_ce;
+    swoole_coroutine_curl_handle_ce->create_object = swoole_curl_create_object;
+    memcpy(&swoole_coroutine_curl_handle_handlers, &std_object_handlers, sizeof(zend_object_handlers));
+    swoole_coroutine_curl_handle_handlers.offset = XtOffsetOf(php_curl, std);
+    swoole_coroutine_curl_handle_handlers.free_obj = swoole_curl_free_obj;
+    swoole_coroutine_curl_handle_handlers.get_gc = swoole_curl_get_gc;
+    swoole_coroutine_curl_handle_handlers.get_constructor = swoole_curl_get_constructor;
+    swoole_coroutine_curl_handle_handlers.clone_obj = swoole_curl_clone_obj;
+    swoole_coroutine_curl_handle_handlers.cast_object = swoole_curl_cast_object;
+    swoole_coroutine_curl_handle_handlers.compare = [](zval *o1, zval *o2) { return ZEND_UNCOMPARABLE; };
+
+    swoole_coroutine_curl_handle_ce->ce_flags |= ZEND_ACC_FINAL | ZEND_ACC_NO_DYNAMIC_PROPERTIES;
+    zend_declare_property_null(swoole_coroutine_curl_handle_ce, ZEND_STRL("private_data"), ZEND_ACC_PUBLIC);
+
+    curl_multi_register_class(nullptr);
+
+    zend_unregister_functions(swoole_native_curl_functions, -1, CG(function_table));
+    zend_register_functions(NULL, swoole_native_curl_functions, NULL, MODULE_PERSISTENT);
+
+    SW_INIT_CLASS_ENTRY_EX(swoole_native_curl_exception,
+                           "Swoole\\Coroutine\\Curl\\Exception",
+                           "Co\\Coroutine\\Curl\\Exception",
+                           nullptr,
+                           swoole_exception);
+}
+/* }}} */
+
+/* CurlHandle class */
+
+static zend_object *swoole_curl_create_object(zend_class_entry *class_type) {
+    php_curl *intern = (php_curl *) zend_object_alloc(sizeof(php_curl), class_type);
+
+    zend_object_std_init(&intern->std, class_type);
+    object_properties_init(&intern->std, class_type);
+    intern->std.handlers = &swoole_coroutine_curl_handle_handlers;
+
+    return &intern->std;
+}
+
+static zend_function *swoole_curl_get_constructor(zend_object *object) {
+    zend_throw_error(NULL, "Cannot directly construct CurlHandle, use curl_init() instead");
+    return NULL;
+}
+
+static zend_object *swoole_curl_clone_obj(zend_object *object) {
+    php_curl *ch;
+    CURL *cp;
+    zval *postfields;
+    zend_object *clone_object;
+    php_curl *clone_ch;
+
+    clone_object = swoole_curl_create_object(curl_ce);
+    clone_ch = curl_from_obj(clone_object);
+    swoole_curl_init_handle(clone_ch);
+
+    ch = curl_from_obj(object);
+    cp = curl_easy_duphandle(ch->cp);
+    if (!cp) {
+        zend_throw_exception(NULL, "Failed to clone CurlHandle", 0);
+        return &clone_ch->std;
+    }
+
+    clone_ch->cp = cp;
+    swoole_setup_easy_copy_handlers(clone_ch, ch);
+    swoole::curl::create_handle(clone_ch->cp);
+
+    postfields = &clone_ch->postfields;
+    if (Z_TYPE_P(postfields) != IS_UNDEF) {
+        if (build_mime_structure_from_hash(clone_ch, postfields) == FAILURE) {
+            zend_throw_exception(NULL, "Failed to clone CurlHandle", 0);
+            return &clone_ch->std;
+        }
+    }
+
+    return &clone_ch->std;
+}
+
+static HashTable *swoole_curl_get_gc(zend_object *object, zval **table, int *n) {
+    php_curl *curl = curl_from_obj(object);
+
+    zend_get_gc_buffer *gc_buffer = zend_get_gc_buffer_create();
+
+    zend_get_gc_buffer_add_zval(gc_buffer, &curl->postfields);
+    if (curl->handlers.read) {
+        if (ZEND_FCC_INITIALIZED(curl->handlers.read->fcc)) {
+            zend_get_gc_buffer_add_fcc(gc_buffer, &curl->handlers.read->fcc);
+        }
+        zend_get_gc_buffer_add_zval(gc_buffer, &curl->handlers.read->stream);
+    }
+
+    if (curl->handlers.write) {
+        if (ZEND_FCC_INITIALIZED(curl->handlers.write->fcc)) {
+            zend_get_gc_buffer_add_fcc(gc_buffer, &curl->handlers.write->fcc);
+        }
+        zend_get_gc_buffer_add_zval(gc_buffer, &curl->handlers.write->stream);
+    }
+
+    if (curl->handlers.write_header) {
+        if (ZEND_FCC_INITIALIZED(curl->handlers.write_header->fcc)) {
+            zend_get_gc_buffer_add_fcc(gc_buffer, &curl->handlers.write_header->fcc);
+        }
+        zend_get_gc_buffer_add_zval(gc_buffer, &curl->handlers.write_header->stream);
+    }
+
+    if (ZEND_FCC_INITIALIZED(curl->handlers.progress)) {
+        zend_get_gc_buffer_add_fcc(gc_buffer, &curl->handlers.progress);
+    }
+
+    if (ZEND_FCC_INITIALIZED(curl->handlers.xferinfo)) {
+        zend_get_gc_buffer_add_fcc(gc_buffer, &curl->handlers.xferinfo);
+    }
+
+    if (ZEND_FCC_INITIALIZED(curl->handlers.fnmatch)) {
+        zend_get_gc_buffer_add_fcc(gc_buffer, &curl->handlers.fnmatch);
+    }
+
+#if LIBCURL_VERSION_NUM >= 0x075400 /* Available since 7.84.0 */
+    if (ZEND_FCC_INITIALIZED(curl->handlers.sshhostkey)) {
+        zend_get_gc_buffer_add_fcc(gc_buffer, &curl->handlers.sshhostkey);
+    }
+#endif
+
+    zend_get_gc_buffer_add_zval(gc_buffer, &curl->handlers.std_err);
+    zend_get_gc_buffer_add_zval(gc_buffer, &curl->private_data);
+
+    zend_get_gc_buffer_use(gc_buffer, table, n);
+
+    return zend_std_get_properties(object);
+}
+
+zend_result swoole_curl_cast_object(zend_object *obj, zval *result, int type) {
+    if (type == IS_LONG) {
+        /* For better backward compatibility, make (int) $curl_handle return the object ID,
+         * similar to how it previously returned the resource ID. */
+        ZVAL_LONG(result, obj->handle);
+        return SUCCESS;
+    }
+
+    return zend_std_cast_object_tostring(obj, result, type);
+}
+
+void swoole_native_curl_mshutdown() {}
+
+/* {{{ curl_write */
+static size_t fn_write(char *data, size_t size, size_t nmemb, void *ctx) {
+    php_curl *ch = (php_curl *) ctx;
+    php_curl_write *write_handler = ch->handlers.write;
+    size_t length = size * nmemb;
+
+#if PHP_CURL_DEBUG
+    fprintf(stderr, "curl_write() called\n");
+    fprintf(stderr, "data = %s, size = %d, nmemb = %d, ctx = %x\n", data, size, nmemb, ctx);
+#endif
+
+    switch (write_handler->method) {
+    case PHP_CURL_STDOUT:
+        PHPWRITE(data, length);
+        break;
+    case PHP_CURL_FILE:
+        return fwrite(data, size, nmemb, write_handler->fp);
+    case PHP_CURL_RETURN:
+        if (length > 0) {
+            smart_str_appendl(&write_handler->buf, data, (int) length);
+        }
+        break;
+    case PHP_CURL_USER: {
+        zval argv[2];
+        zval retval;
+
+        GC_ADDREF(&ch->std);
+        ZVAL_OBJ(&argv[0], &ch->std);
+        ZVAL_STRINGL(&argv[1], data, length);
+
+        ch->in_callback = true;
+        zend_call_known_fcc(&write_handler->fcc, &retval, /* param_count */ 2, argv, /* named_params */ NULL);
+        ch->in_callback = false;
+        if (!Z_ISUNDEF(retval)) {
+            swoole_curl_verify_handlers(ch, /* reporterror */ true);
+            /* TODO Check callback returns an int or something castable to int */
+            length = zval_get_long(&retval);
+        }
+
+        zval_ptr_dtor(&argv[0]);
+        zval_ptr_dtor(&argv[1]);
+        break;
+    }
+    }
+
+    return length;
+}
+/* }}} */
+
+/* {{{ curl_fnmatch */
+static int fn_fnmatch(void *ctx, const char *pattern, const char *string) {
+    php_curl *ch = (php_curl *) ctx;
+    int rval = CURL_FNMATCHFUNC_FAIL;
+    zval argv[3];
+    zval retval;
+
+    GC_ADDREF(&ch->std);
+    ZVAL_OBJ(&argv[0], &ch->std);
+    ZVAL_STRING(&argv[1], pattern);
+    ZVAL_STRING(&argv[2], string);
+
+    ch->in_callback = true;
+    zend_call_known_fcc(&ch->handlers.fnmatch, &retval, /* param_count */ 3, argv, /* named_params */ NULL);
+    ch->in_callback = false;
+
+    if (!Z_ISUNDEF(retval)) {
+        swoole_curl_verify_handlers(ch, /* reporterror */ true);
+        /* TODO Check callback returns an int or something castable to int */
+        rval = zval_get_long(&retval);
+    }
+    zval_ptr_dtor(&argv[0]);
+    zval_ptr_dtor(&argv[1]);
+    zval_ptr_dtor(&argv[2]);
+    return rval;
+}
+/* }}} */
+
+/* {{{ curl_progress */
+static size_t fn_progress(void *clientp, double dltotal, double dlnow, double ultotal, double ulnow) {
+    php_curl *ch = (php_curl *) clientp;
+    size_t rval = 0;
+
+#if PHP_CURL_DEBUG
+    fprintf(stderr, "curl_progress() called\n");
+    fprintf(stderr,
+            "clientp = %x, dltotal = %f, dlnow = %f, ultotal = %f, ulnow = %f\n",
+            clientp,
+            dltotal,
+            dlnow,
+            ultotal,
+            ulnow);
+#endif
+
+    zval args[5];
+    zval retval;
+
+    GC_ADDREF(&ch->std);
+    ZVAL_OBJ(&args[0], &ch->std);
+    ZVAL_LONG(&args[1], (zend_long) dltotal);
+    ZVAL_LONG(&args[2], (zend_long) dlnow);
+    ZVAL_LONG(&args[3], (zend_long) ultotal);
+    ZVAL_LONG(&args[4], (zend_long) ulnow);
+
+    ch->in_callback = true;
+    zend_call_known_fcc(&ch->handlers.progress, &retval, /* param_count */ 5, args, /* named_params */ NULL);
+    ch->in_callback = false;
+
+    if (!Z_ISUNDEF(retval)) {
+        swoole_curl_verify_handlers(ch, /* reporterror */ true);
+        /* TODO Check callback returns an int or something castable to int */
+        if (0 != zval_get_long(&retval)) {
+            rval = 1;
+        }
+    }
+
+    zval_ptr_dtor(&args[0]);
+    return rval;
+}
+/* }}} */
+
+/* {{{ curl_xferinfo */
+static size_t fn_xferinfo(void *clientp, curl_off_t dltotal, curl_off_t dlnow, curl_off_t ultotal, curl_off_t ulnow) {
+    php_curl *ch = (php_curl *) clientp;
+    size_t rval = 0;
+
+#if PHP_CURL_DEBUG
+    fprintf(stderr, "curl_xferinfo() called\n");
+    fprintf(stderr,
+            "clientp = %x, dltotal = %ld, dlnow = %ld, ultotal = %ld, ulnow = %ld\n",
+            clientp,
+            dltotal,
+            dlnow,
+            ultotal,
+            ulnow);
+#endif
+
+    zval argv[5];
+    zval retval;
+
+    GC_ADDREF(&ch->std);
+    ZVAL_OBJ(&argv[0], &ch->std);
+    ZVAL_LONG(&argv[1], dltotal);
+    ZVAL_LONG(&argv[2], dlnow);
+    ZVAL_LONG(&argv[3], ultotal);
+    ZVAL_LONG(&argv[4], ulnow);
+
+    ch->in_callback = true;
+    zend_call_known_fcc(&ch->handlers.xferinfo, &retval, /* param_count */ 5, argv, /* named_params */ NULL);
+    ch->in_callback = false;
+
+    if (!Z_ISUNDEF(retval)) {
+        swoole_curl_verify_handlers(ch, /* reporterror */ true);
+        /* TODO Check callback returns an int or something castable to int */
+        if (0 != zval_get_long(&retval)) {
+            rval = 1;
+        }
+    }
+
+    zval_ptr_dtor(&argv[0]);
+    return rval;
+}
+/* }}} */
+
+#if LIBCURL_VERSION_NUM >= 0x075400 /* Available since 7.84.0 */
+static int fn_ssh_hostkeyfunction(void *clientp, int keytype, const char *key, size_t keylen) {
+    php_curl *ch = (php_curl *) clientp;
+    int rval = CURLKHMATCH_MISMATCH; /* cancel connection in case of an exception */
+
+#if PHP_CURL_DEBUG
+    fprintf(stderr, "curl_ssh_hostkeyfunction() called\n");
+    fprintf(stderr, "clientp = %x, keytype = %d, key = %s, keylen = %zu\n", clientp, keytype, key, keylen);
+#endif
+
+    zval args[4];
+    zval retval;
+
+    GC_ADDREF(&ch->std);
+    ZVAL_OBJ(&args[0], &ch->std);
+    ZVAL_LONG(&args[1], keytype);
+    ZVAL_STRINGL(&args[2], key, keylen);
+    ZVAL_LONG(&args[3], keylen);
+
+    ch->in_callback = true;
+    zend_call_known_fcc(&ch->handlers.sshhostkey, &retval, /* param_count */ 4, args, /* named_params */ NULL);
+    ch->in_callback = false;
+
+    if (!Z_ISUNDEF(retval)) {
+        swoole_curl_verify_handlers(ch, /* reporterror */ true);
+        if (Z_TYPE(retval) == IS_LONG) {
+            zend_long retval_long = Z_LVAL(retval);
+            if (retval_long == CURLKHMATCH_OK || retval_long == CURLKHMATCH_MISMATCH) {
+                rval = retval_long;
+            } else {
+                zend_throw_error(NULL,
+                                 "The CURLOPT_SSH_HOSTKEYFUNCTION callback must return either CURLKHMATCH_OK or "
+                                 "CURLKHMATCH_MISMATCH");
+            }
+        } else {
+            zend_throw_error(
+                NULL,
+                "The CURLOPT_SSH_HOSTKEYFUNCTION callback must return either CURLKHMATCH_OK or CURLKHMATCH_MISMATCH");
+        }
+    }
+
+    zval_ptr_dtor(&args[0]);
+    zval_ptr_dtor(&args[2]);
+    return rval;
+}
+#endif
+
+/* {{{ curl_read */
+static size_t fn_read(char *data, size_t size, size_t nmemb, void *ctx) {
+    php_curl *ch = (php_curl *) ctx;
+    php_curl_read *read_handler = ch->handlers.read;
+    int length = 0;
+
+    switch (read_handler->method) {
+    case PHP_CURL_DIRECT:
+        if (read_handler->fp) {
+            length = fread(data, size, nmemb, read_handler->fp);
+        }
+        break;
+    case PHP_CURL_USER: {
+        zval argv[3];
+        zval retval;
+
+        GC_ADDREF(&ch->std);
+        ZVAL_OBJ(&argv[0], &ch->std);
+        if (read_handler->res) {
+            GC_ADDREF(read_handler->res);
+            ZVAL_RES(&argv[1], read_handler->res);
+        } else {
+            ZVAL_NULL(&argv[1]);
+        }
+        ZVAL_LONG(&argv[2], (int) size * nmemb);
+
+        ch->in_callback = true;
+        zend_call_known_fcc(&read_handler->fcc, &retval, /* param_count */ 3, argv, /* named_params */ NULL);
+        ch->in_callback = false;
+        if (!Z_ISUNDEF(retval)) {
+            swoole_curl_verify_handlers(ch, /* reporterror */ true);
+            if (Z_TYPE(retval) == IS_STRING) {
+                length = MIN((size * nmemb), Z_STRLEN(retval));
+                memcpy(data, Z_STRVAL(retval), length);
+            } else if (Z_TYPE(retval) == IS_LONG) {
+                length = Z_LVAL_P(&retval);
+            }
+            // TODO Do type error if invalid type?
+            zval_ptr_dtor(&retval);
+        }
+
+        zval_ptr_dtor(&argv[0]);
+        zval_ptr_dtor(&argv[1]);
+        break;
+    }
+    }
+
+    return length;
+}
+/* }}} */
+
+/* {{{ curl_write_header */
+static size_t fn_write_header(char *data, size_t size, size_t nmemb, void *ctx) {
+    php_curl *ch = (php_curl *) ctx;
+    php_curl_write *write_handler = ch->handlers.write_header;
+    size_t length = size * nmemb;
+
+    switch (write_handler->method) {
+    case PHP_CURL_STDOUT:
+        /* Handle special case write when we're returning the entire transfer
+         */
+        if (ch->handlers.write->method == PHP_CURL_RETURN && length > 0) {
+            smart_str_appendl(&ch->handlers.write->buf, data, (int) length);
+        } else {
+            PHPWRITE(data, length);
+        }
+        break;
+    case PHP_CURL_FILE:
+        return fwrite(data, size, nmemb, write_handler->fp);
+    case PHP_CURL_USER: {
+        zval argv[2];
+        zval retval;
+
+        GC_ADDREF(&ch->std);
+        ZVAL_OBJ(&argv[0], &ch->std);
+        ZVAL_STRINGL(&argv[1], data, length);
+
+        ch->in_callback = true;
+        zend_call_known_fcc(&write_handler->fcc, &retval, /* param_count */ 2, argv, /* named_params */ NULL);
+        ch->in_callback = false;
+        if (!Z_ISUNDEF(retval)) {
+            // TODO: Check for valid int type for return value
+            swoole_curl_verify_handlers(ch, /* reporterror */ true);
+            length = zval_get_long(&retval);
+        }
+        zval_ptr_dtor(&argv[0]);
+        zval_ptr_dtor(&argv[1]);
+        break;
+    }
+
+    case PHP_CURL_IGNORE:
+        return length;
+
+    default:
+        return -1;
+    }
+
+    return length;
+}
+/* }}} */
+
+static int curl_debug(CURL *cp, curl_infotype type, char *buf, size_t buf_len, void *ctx) /* {{{ */
+{
+    php_curl *ch = (php_curl *) ctx;
+
+    if (type == CURLINFO_HEADER_OUT) {
+        if (ch->header.str) {
+            zend_string_release_ex(ch->header.str, 0);
+        }
+        ch->header.str = zend_string_init(buf, buf_len, 0);
+    }
+
+    return 0;
+}
+/* }}} */
+
+/* {{{ curl_free_post */
+static void curl_free_post(void **post) {
+    curl_mime_free((curl_mime *) *post);
+}
+/* }}} */
+
+struct mime_data_cb_arg {
+    zend_string *filename;
+    php_stream *stream;
+};
+
+/* {{{ curl_free_cb_arg */
+static void curl_free_cb_arg(void **cb_arg_p) {
+    struct mime_data_cb_arg *cb_arg = (struct mime_data_cb_arg *) *cb_arg_p;
+
+    ZEND_ASSERT(cb_arg->stream == NULL);
+    zend_string_release(cb_arg->filename);
+    efree(cb_arg);
+}
+/* }}} */
+
+/* {{{ curl_free_slist */
+static void curl_free_slist(zval *el) {
+    curl_slist_free_all(((struct curl_slist *) Z_PTR_P(el)));
+}
+/* }}} */
+
+/* {{{ Return cURL version information. */
+PHP_FUNCTION(swoole_native_curl_version) {
+    curl_version_info_data *d;
+
+    ZEND_PARSE_PARAMETERS_NONE();
+
+    d = curl_version_info(CURLVERSION_NOW);
+    if (d == NULL) {
+        RETURN_FALSE;
+    }
+
+    array_init(return_value);
+
+    CAAL("version_number", d->version_num);
+    CAAL("age", d->age);
+    CAAL("features", d->features);
+    /* Add an array of features */
+    {
+        struct feat {
+            const char *name;
+            int bitmask;
+        };
+
+        unsigned int i;
+        zval feature_list;
+        array_init(&feature_list);
+
+        /* Sync this list with PHP_MINFO_FUNCTION(curl) as well */
+        static const struct feat feats[] = {
+            {"AsynchDNS", CURL_VERSION_ASYNCHDNS},
+            {"CharConv", CURL_VERSION_CONV},
+            {"Debug", CURL_VERSION_DEBUG},
+            {"GSS-Negotiate", CURL_VERSION_GSSNEGOTIATE},
+            {"IDN", CURL_VERSION_IDN},
+            {"IPv6", CURL_VERSION_IPV6},
+            {"krb4", CURL_VERSION_KERBEROS4},
+            {"Largefile", CURL_VERSION_LARGEFILE},
+            {"libz", CURL_VERSION_LIBZ},
+            {"NTLM", CURL_VERSION_NTLM},
+            {"NTLMWB", CURL_VERSION_NTLM_WB},
+            {"SPNEGO", CURL_VERSION_SPNEGO},
+            {"SSL", CURL_VERSION_SSL},
+            {"SSPI", CURL_VERSION_SSPI},
+            {"TLS-SRP", CURL_VERSION_TLSAUTH_SRP},
+            {"HTTP2", CURL_VERSION_HTTP2},
+            {"GSSAPI", CURL_VERSION_GSSAPI},
+            {"KERBEROS5", CURL_VERSION_KERBEROS5},
+            {"UNIX_SOCKETS", CURL_VERSION_UNIX_SOCKETS},
+            {"PSL", CURL_VERSION_PSL},
+            {"HTTPS_PROXY", CURL_VERSION_HTTPS_PROXY},
+            {"MULTI_SSL", CURL_VERSION_MULTI_SSL},
+            {"BROTLI", CURL_VERSION_BROTLI},
+#if LIBCURL_VERSION_NUM >= 0x074001 /* Available since 7.64.1 */
+            {"ALTSVC", CURL_VERSION_ALTSVC},
+#endif
+#if LIBCURL_VERSION_NUM >= 0x074200 /* Available since 7.66.0 */
+            {"HTTP3", CURL_VERSION_HTTP3},
+#endif
+#if LIBCURL_VERSION_NUM >= 0x074800 /* Available since 7.72.0 */
+            {"UNICODE", CURL_VERSION_UNICODE},
+            {"ZSTD", CURL_VERSION_ZSTD},
+#endif
+#if LIBCURL_VERSION_NUM >= 0x074a00 /* Available since 7.74.0 */
+            {"HSTS", CURL_VERSION_HSTS},
+#endif
+#if LIBCURL_VERSION_NUM >= 0x074c00 /* Available since 7.76.0 */
+            {"GSASL", CURL_VERSION_GSASL},
+#endif
+        };
+
+        for (i = 0; i < sizeof(feats) / sizeof(feats[0]); i++) {
+            if (feats[i].name) {
+                add_assoc_bool(&feature_list, feats[i].name, d->features & feats[i].bitmask ? true : false);
+            }
+        }
+
+        CAAZ("feature_list", &feature_list);
+    }
+    CAAL("ssl_version_number", d->ssl_version_num);
+    CAAS("version", d->version);
+    CAAS("host", d->host);
+    CAAS("ssl_version", d->ssl_version);
+    CAAS("libz_version", d->libz_version);
+    /* Add an array of protocols */
+    {
+        char **p = (char **) d->protocols;
+        zval protocol_list;
+
+        array_init(&protocol_list);
+
+        while (*p != NULL) {
+            add_next_index_string(&protocol_list, *p);
+            p++;
+        }
+        CAAZ("protocols", &protocol_list);
+    }
+    if (d->age >= 1) {
+        CAAS("ares", d->ares);
+        CAAL("ares_num", d->ares_num);
+    }
+    if (d->age >= 2) {
+        CAAS("libidn", d->libidn);
+    }
+    if (d->age >= 3) {
+        CAAL("iconv_ver_num", d->iconv_ver_num);
+        CAAS("libssh_version", d->libssh_version);
+    }
+    if (d->age >= 4) {
+        CAAL("brotli_ver_num", d->brotli_ver_num);
+        CAAS("brotli_version", d->brotli_version);
+    }
+}
+/* }}} */
+
+php_curl *swoole_curl_init_handle_into_zval(zval *curl) {
+    php_curl *ch;
+
+    object_init_ex(curl, swoole_coroutine_curl_handle_ce);
+    ch = Z_CURL_P(curl);
+
+    swoole_curl_init_handle(ch);
+
+    return ch;
+}
+
+void swoole_curl_init_handle(php_curl *ch) {
+    ch->to_free = (struct _php_curl_free *) ecalloc(1, sizeof(struct _php_curl_free));
+    ch->handlers.write = (php_curl_write *) ecalloc(1, sizeof(php_curl_write));
+    ch->handlers.write_header = (php_curl_write *) ecalloc(1, sizeof(php_curl_write));
+    ch->handlers.read = (php_curl_read *) ecalloc(1, sizeof(php_curl_read));
+    ch->handlers.progress = empty_fcall_info_cache;
+    ch->handlers.xferinfo = empty_fcall_info_cache;
+    ch->handlers.fnmatch = empty_fcall_info_cache;
+#if LIBCURL_VERSION_NUM >= 0x075400 /* Available since 7.84.0 */
+    ch->handlers.sshhostkey = empty_fcall_info_cache;
+#endif
+    ch->clone = (uint32_t *) emalloc(sizeof(uint32_t));
+    *ch->clone = 1;
+
+    memset(&ch->err, 0, sizeof(struct _php_curl_error));
+
+    zend_llist_init(&ch->to_free->post, sizeof(struct HttpPost *), (llist_dtor_func_t) curl_free_post, 0);
+    zend_llist_init(&ch->to_free->stream, sizeof(struct mime_data_cb_arg *), (llist_dtor_func_t) curl_free_cb_arg, 0);
+
+    ch->to_free->slist = (HashTable *) emalloc(sizeof(HashTable));
+    zend_hash_init(ch->to_free->slist, 4, NULL, curl_free_slist, 0);
+    ZVAL_UNDEF(&ch->postfields);
+}
+
+/* }}} */
+
+/* {{{ create_certinfo */
+static void create_certinfo(struct curl_certinfo *ci, zval *listcode) {
+    int i;
+
+    if (ci) {
+        zval certhash;
+
+        for (i = 0; i < ci->num_of_certs; i++) {
+            struct curl_slist *slist;
+
+            array_init(&certhash);
+            for (slist = ci->certinfo[i]; slist; slist = slist->next) {
+                int len;
+                char s[64];
+                char *tmp;
+                strncpy(s, slist->data, sizeof(s));
+                s[sizeof(s) - 1] = '\0';
+                tmp = (char *)  memchr(s, ':', sizeof(s));
+                if (tmp) {
+                    *tmp = '\0';
+                    len = strlen(s);
+                    add_assoc_string(&certhash, s, &slist->data[len + 1]);
+                } else {
+                    php_error_docref(NULL, E_WARNING, "Could not extract hash key from certificate info");
+                }
+            }
+            add_next_index_zval(listcode, &certhash);
+        }
+    }
+}
+/* }}} */
+
+/* {{{ _php_curl_set_default_options()
+   Set default options for a handle */
+static void _php_curl_set_default_options(php_curl *ch) {
+    char *cainfo;
+
+    curl_easy_setopt(ch->cp, CURLOPT_NOPROGRESS, 1);
+    curl_easy_setopt(ch->cp, CURLOPT_VERBOSE, 0);
+    curl_easy_setopt(ch->cp, CURLOPT_ERRORBUFFER, ch->err.str);
+    curl_easy_setopt(ch->cp, CURLOPT_WRITEFUNCTION, fn_write);
+    curl_easy_setopt(ch->cp, CURLOPT_FILE, (void *) ch);
+    curl_easy_setopt(ch->cp, CURLOPT_READFUNCTION, fn_read);
+    curl_easy_setopt(ch->cp, CURLOPT_INFILE, (void *) ch);
+    curl_easy_setopt(ch->cp, CURLOPT_HEADERFUNCTION, fn_write_header);
+    curl_easy_setopt(ch->cp, CURLOPT_WRITEHEADER, (void *) ch);
+#ifndef ZTS
+    curl_easy_setopt(ch->cp, CURLOPT_DNS_USE_GLOBAL_CACHE, 1);
+#endif
+    curl_easy_setopt(ch->cp, CURLOPT_DNS_CACHE_TIMEOUT, 120);
+    curl_easy_setopt(ch->cp, CURLOPT_MAXREDIRS, 20); /* prevent infinite redirects */
+
+    cainfo = INI_STR("openssl.cafile");
+    if (!(cainfo && cainfo[0] != '\0')) {
+        cainfo = INI_STR("curl.cainfo");
+    }
+    if (cainfo && cainfo[0] != '\0') {
+        curl_easy_setopt(ch->cp, CURLOPT_CAINFO, cainfo);
+    }
+
+#ifdef ZTS
+    curl_easy_setopt(ch->cp, CURLOPT_NOSIGNAL, 1);
+#endif
+}
+/* }}} */
+
+/* {{{ Initialize a cURL session */
+PHP_FUNCTION(swoole_native_curl_init) {
+    php_curl *ch;
+    CURL *cp;
+    zend_string *url = NULL;
+
+    ZEND_PARSE_PARAMETERS_START(0, 1)
+    Z_PARAM_OPTIONAL
+    Z_PARAM_STR_OR_NULL(url)
+    ZEND_PARSE_PARAMETERS_END();
+
+    cp = curl_easy_init();
+    if (!cp) {
+        php_error_docref(NULL, E_WARNING, "Could not initialize a new cURL handle");
+        RETURN_FALSE;
+    }
+
+    ch = swoole_curl_init_handle_into_zval(return_value);
+
+    ch->cp = cp;
+
+    ch->handlers.write->method = PHP_CURL_STDOUT;
+    ch->handlers.read->method = PHP_CURL_DIRECT;
+    ch->handlers.write_header->method = PHP_CURL_IGNORE;
+
+    _php_curl_set_default_options(ch);
+    swoole::curl::create_handle(cp);
+
+    if (url) {
+        if (php_curl_option_url(ch, url) == FAILURE) {
+            zval_ptr_dtor(return_value);
+            RETURN_FALSE;
+        }
+    }
+}
+/* }}} */
+
+static void php_curl_copy_fcc_with_option(php_curl *ch,
+                                          CURLoption option,
+                                          zend_fcall_info_cache *target_fcc,
+                                          zend_fcall_info_cache *source_fcc) {
+    if (ZEND_FCC_INITIALIZED(*source_fcc)) {
+        zend_fcc_dup(target_fcc, source_fcc);
+        curl_easy_setopt(ch->cp, (CURLoption) option, (void *) ch);
+    }
+}
+
+void swoole_setup_easy_copy_handlers(php_curl *ch, php_curl *source) {
+    if (!Z_ISUNDEF(source->handlers.write->stream)) {
+        Z_ADDREF(source->handlers.write->stream);
+    }
+    ch->handlers.write->stream = source->handlers.write->stream;
+    ch->handlers.write->method = source->handlers.write->method;
+    if (!Z_ISUNDEF(source->handlers.read->stream)) {
+        Z_ADDREF(source->handlers.read->stream);
+    }
+    ch->handlers.read->stream = source->handlers.read->stream;
+    ch->handlers.read->method = source->handlers.read->method;
+    ch->handlers.write_header->method = source->handlers.write_header->method;
+    if (!Z_ISUNDEF(source->handlers.write_header->stream)) {
+        Z_ADDREF(source->handlers.write_header->stream);
+    }
+    ch->handlers.write_header->stream = source->handlers.write_header->stream;
+
+    ch->handlers.write->fp = source->handlers.write->fp;
+    ch->handlers.write_header->fp = source->handlers.write_header->fp;
+    ch->handlers.read->fp = source->handlers.read->fp;
+    ch->handlers.read->res = source->handlers.read->res;
+
+    if (ZEND_FCC_INITIALIZED(source->handlers.read->fcc)) {
+        zend_fcc_dup(&source->handlers.read->fcc, &source->handlers.read->fcc);
+    }
+    if (ZEND_FCC_INITIALIZED(source->handlers.write->fcc)) {
+        zend_fcc_dup(&source->handlers.write->fcc, &source->handlers.write->fcc);
+    }
+    if (ZEND_FCC_INITIALIZED(source->handlers.write_header->fcc)) {
+        zend_fcc_dup(&source->handlers.write_header->fcc, &source->handlers.write_header->fcc);
+    }
+
+    curl_easy_setopt(ch->cp, CURLOPT_ERRORBUFFER, ch->err.str);
+    curl_easy_setopt(ch->cp, CURLOPT_FILE, (void *) ch);
+    curl_easy_setopt(ch->cp, CURLOPT_INFILE, (void *) ch);
+    curl_easy_setopt(ch->cp, CURLOPT_WRITEHEADER, (void *) ch);
+    curl_easy_setopt(ch->cp, CURLOPT_DEBUGDATA, (void *) ch);
+
+    php_curl_copy_fcc_with_option(ch, CURLOPT_PROGRESSDATA, &ch->handlers.progress, &source->handlers.progress);
+    php_curl_copy_fcc_with_option(ch, CURLOPT_XFERINFODATA, &ch->handlers.xferinfo, &source->handlers.xferinfo);
+    php_curl_copy_fcc_with_option(ch, CURLOPT_FNMATCH_DATA, &ch->handlers.fnmatch, &source->handlers.fnmatch);
+#if LIBCURL_VERSION_NUM >= 0x075400 /* Available since 7.84.0 */
+    php_curl_copy_fcc_with_option(ch, CURLOPT_SSH_HOSTKEYDATA, &ch->handlers.sshhostkey, &source->handlers.sshhostkey);
+#endif
+
+    ZVAL_COPY(&ch->private_data, &source->private_data);
+
+    efree(ch->to_free->slist);
+    efree(ch->to_free);
+    ch->to_free = source->to_free;
+    efree(ch->clone);
+    ch->clone = source->clone;
+
+    /* Keep track of cloned copies to avoid invoking curl destructors for every clone */
+    (*source->clone)++;
+}
+
+static size_t read_cb(char *buffer, size_t size, size_t nitems, void *arg) /* {{{ */
+{
+    struct mime_data_cb_arg *cb_arg = (struct mime_data_cb_arg *) arg;
+    ssize_t numread;
+
+    if (cb_arg->stream == NULL) {
+        if (!(cb_arg->stream = php_stream_open_wrapper(ZSTR_VAL(cb_arg->filename), "rb", IGNORE_PATH, NULL))) {
+            return CURL_READFUNC_ABORT;
+        }
+    }
+    numread = php_stream_read(cb_arg->stream, buffer, nitems * size);
+    if (numread < 0) {
+        php_stream_close(cb_arg->stream);
+        cb_arg->stream = NULL;
+        return CURL_READFUNC_ABORT;
+    }
+    return numread;
+}
+/* }}} */
+
+static int seek_cb(void *arg, curl_off_t offset, int origin) /* {{{ */
+{
+    struct mime_data_cb_arg *cb_arg = (struct mime_data_cb_arg *) arg;
+    int res;
+
+    if (cb_arg->stream == NULL) {
+        return CURL_SEEKFUNC_CANTSEEK;
+    }
+    res = php_stream_seek(cb_arg->stream, offset, origin);
+    return res == SUCCESS ? CURL_SEEKFUNC_OK : CURL_SEEKFUNC_CANTSEEK;
+}
+/* }}} */
+
+static void free_cb(void *arg) /* {{{ */
+{
+    struct mime_data_cb_arg *cb_arg = (struct mime_data_cb_arg *) arg;
+
+    if (cb_arg->stream != NULL) {
+        php_stream_close(cb_arg->stream);
+        cb_arg->stream = NULL;
+    }
+}
+/* }}} */
+
+static inline CURLcode add_simple_field(curl_mime *mime, zend_string *string_key, zval *current) {
+    CURLcode error = CURLE_OK;
+    curl_mimepart *part;
+    CURLcode form_error;
+    zend_string *postval, *tmp_postval;
+
+    postval = zval_get_tmp_string(current, &tmp_postval);
+
+    part = curl_mime_addpart(mime);
+    if (part == NULL) {
+        zend_tmp_string_release(tmp_postval);
+        zend_string_release_ex(string_key, 0);
+        return CURLE_OUT_OF_MEMORY;
+    }
+    if ((form_error = curl_mime_name(part, ZSTR_VAL(string_key))) != CURLE_OK ||
+        (form_error = curl_mime_data(part, ZSTR_VAL(postval), ZSTR_LEN(postval))) != CURLE_OK) {
+        error = form_error;
+    }
+
+    zend_tmp_string_release(tmp_postval);
+
+    return error;
+}
+
+static inline zend_result build_mime_structure_from_hash(php_curl *ch, zval *zpostfields) /* {{{ */
+{
+    HashTable *postfields = Z_ARRVAL_P(zpostfields);
+    CURLcode error = CURLE_OK;
+    zval *current;
+    zend_string *string_key;
+    zend_ulong num_key;
+    curl_mime *mime = NULL;
+    curl_mimepart *part;
+    CURLcode form_error;
+
+    if (zend_hash_num_elements(postfields) > 0) {
+        mime = curl_mime_init(ch->cp);
+        if (mime == NULL) {
+            return FAILURE;
+        }
+    }
+
+    ZEND_HASH_FOREACH_KEY_VAL(postfields, num_key, string_key, current) {
+        zend_string *postval;
+        /* Pretend we have a string_key here */
+        if (!string_key) {
+            string_key = zend_long_to_str(num_key);
+        } else {
+            zend_string_addref(string_key);
+        }
+
+        ZVAL_DEREF(current);
+        if (Z_TYPE_P(current) == IS_OBJECT && instanceof_function(Z_OBJCE_P(current), curl_CURLFile_class)) {
+            /* new-style file upload */
+            zval *prop, rv;
+            char *type = NULL, *filename = NULL;
+            struct mime_data_cb_arg *cb_arg;
+            php_stream *stream;
+            php_stream_statbuf ssb;
+            size_t filesize = -1;
+            curl_seek_callback seekfunc = seek_cb;
+
+            prop = zend_read_property_ex(
+                curl_CURLFile_class, Z_OBJ_P(current), ZSTR_KNOWN(ZEND_STR_NAME), /* silent */ false, &rv);
+            ZVAL_DEREF(prop);
+            if (Z_TYPE_P(prop) != IS_STRING) {
+                php_error_docref(NULL, E_WARNING, "Invalid filename for key %s", ZSTR_VAL(string_key));
+            } else {
+                postval = Z_STR_P(prop);
+
+                if (php_check_open_basedir(ZSTR_VAL(postval))) {
+                    return FAILURE;
+                }
+
+                prop = zend_read_property(curl_CURLFile_class, Z_OBJ_P(current), "mime", sizeof("mime") - 1, 0, &rv);
+                ZVAL_DEREF(prop);
+                if (Z_TYPE_P(prop) == IS_STRING && Z_STRLEN_P(prop) > 0) {
+                    type = Z_STRVAL_P(prop);
+                }
+                prop = zend_read_property(
+                    curl_CURLFile_class, Z_OBJ_P(current), "postname", sizeof("postname") - 1, 0, &rv);
+                ZVAL_DEREF(prop);
+                if (Z_TYPE_P(prop) == IS_STRING && Z_STRLEN_P(prop) > 0) {
+                    filename = Z_STRVAL_P(prop);
+                }
+
+                zval_ptr_dtor(&ch->postfields);
+                ZVAL_COPY(&ch->postfields, zpostfields);
+
+                if ((stream = php_stream_open_wrapper(ZSTR_VAL(postval), "rb", STREAM_MUST_SEEK, NULL))) {
+                    if (!stream->readfilters.head && !php_stream_stat(stream, &ssb)) {
+                        filesize = ssb.sb.st_size;
+                    }
+                } else {
+                    seekfunc = NULL;
+                }
+
+                cb_arg = (struct mime_data_cb_arg *) emalloc(sizeof *cb_arg);
+                cb_arg->filename = zend_string_copy(postval);
+                cb_arg->stream = stream;
+
+                part = curl_mime_addpart(mime);
+                if (part == NULL) {
+                    zend_string_release_ex(string_key, 0);
+                    return FAILURE;
+                }
+                if ((form_error = curl_mime_name(part, ZSTR_VAL(string_key))) != CURLE_OK ||
+                    (form_error = curl_mime_data_cb(part, filesize, read_cb, seekfunc, free_cb, cb_arg)) != CURLE_OK ||
+                    (form_error = curl_mime_filename(part, filename ? filename : ZSTR_VAL(postval))) != CURLE_OK ||
+                    (form_error = curl_mime_type(part, type ? type : "application/octet-stream")) != CURLE_OK) {
+                    error = form_error;
+                }
+                zend_llist_add_element(&ch->to_free->stream, &cb_arg);
+            }
+
+            zend_string_release_ex(string_key, 0);
+            continue;
+        }
+
+        if (Z_TYPE_P(current) == IS_OBJECT && instanceof_function(Z_OBJCE_P(current), curl_CURLStringFile_class)) {
+            /* new-style file upload from string */
+            zval *prop, rv;
+            char *type = NULL, *filename = NULL;
+
+            prop = zend_read_property(
+                curl_CURLStringFile_class, SW_Z8_OBJ_P(current), "postname", sizeof("postname") - 1, 0, &rv);
+            if (EG(exception)) {
+                zend_string_release_ex(string_key, 0);
+                return FAILURE;
+            }
+            ZVAL_DEREF(prop);
+            ZEND_ASSERT(Z_TYPE_P(prop) == IS_STRING);
+
+            filename = Z_STRVAL_P(prop);
+
+            prop =
+                zend_read_property(curl_CURLStringFile_class, SW_Z8_OBJ_P(current), "mime", sizeof("mime") - 1, 0, &rv);
+            if (EG(exception)) {
+                zend_string_release_ex(string_key, 0);
+                return FAILURE;
+            }
+            ZVAL_DEREF(prop);
+            ZEND_ASSERT(Z_TYPE_P(prop) == IS_STRING);
+
+            type = Z_STRVAL_P(prop);
+
+            prop =
+                zend_read_property(curl_CURLStringFile_class, SW_Z8_OBJ_P(current), "data", sizeof("data") - 1, 0, &rv);
+            if (EG(exception)) {
+                zend_string_release_ex(string_key, 0);
+                return FAILURE;
+            }
+            ZVAL_DEREF(prop);
+            ZEND_ASSERT(Z_TYPE_P(prop) == IS_STRING);
+
+            postval = Z_STR_P(prop);
+
+            zval_ptr_dtor(&ch->postfields);
+            ZVAL_COPY(&ch->postfields, zpostfields);
+
+            part = curl_mime_addpart(mime);
+            if (part == NULL) {
+                zend_string_release_ex(string_key, 0);
+                return FAILURE;
+            }
+            if ((form_error = curl_mime_name(part, ZSTR_VAL(string_key))) != CURLE_OK ||
+                (form_error = curl_mime_data(part, ZSTR_VAL(postval), ZSTR_LEN(postval))) != CURLE_OK ||
+                (form_error = curl_mime_filename(part, filename)) != CURLE_OK ||
+                (form_error = curl_mime_type(part, type)) != CURLE_OK) {
+                error = form_error;
+            }
+
+            zend_string_release_ex(string_key, 0);
+            continue;
+        }
+
+        if (Z_TYPE_P(current) == IS_ARRAY) {
+            zval *current_element;
+
+            ZEND_HASH_FOREACH_VAL(HASH_OF(current), current_element) {
+                add_simple_field(mime, string_key, current_element);
+            }
+            ZEND_HASH_FOREACH_END();
+
+            zend_string_release_ex(string_key, 0);
+            continue;
+        }
+
+        add_simple_field(mime, string_key, current);
+
+        zend_string_release_ex(string_key, 0);
+    }
+    ZEND_HASH_FOREACH_END();
+
+    SAVE_CURL_ERROR(ch, error);
+    if (error != CURLE_OK) {
+        return FAILURE;
+    }
+
+    if ((*ch->clone) == 1) {
+        zend_llist_clean(&ch->to_free->post);
+    }
+    zend_llist_add_element(&ch->to_free->post, &mime);
+    error = curl_easy_setopt(ch->cp, CURLOPT_MIMEPOST, mime);
+
+    SAVE_CURL_ERROR(ch, error);
+    return error == CURLE_OK ? SUCCESS : FAILURE;
+}
+/* }}} */
+
+/* {{{ Copy a cURL handle along with all of it's preferences */
+PHP_FUNCTION(swoole_native_curl_copy_handle) {
+    zval *zid;
+    php_curl *ch;
+
+    ZEND_PARSE_PARAMETERS_START(1, 1)
+    Z_PARAM_OBJECT_OF_CLASS(zid, swoole_coroutine_curl_handle_ce)
+    ZEND_PARSE_PARAMETERS_END();
+
+    if ((ch = swoole_curl_get_handle(zid)) == NULL) {
+        RETURN_FALSE;
+    }
+
+    zend_object *clone_obj = swoole_curl_clone_obj(Z_OBJ_P(zid));
+    if (!clone_obj) {
+        php_error_docref(NULL, E_WARNING, "Cannot duplicate cURL handle");
+        RETURN_FALSE;
+    }
+    RETURN_OBJ(clone_obj);
+}
+/* }}} */
+
+static bool php_curl_set_callable_handler(zend_fcall_info_cache *const handler_fcc,
+                                          zval *callable,
+                                          bool is_array_config,
+                                          const char *option_name) {
+    if (ZEND_FCC_INITIALIZED(*handler_fcc)) {
+        zend_fcc_dtor(handler_fcc);
+    }
+
+    if (Z_TYPE_P(callable) == IS_NULL) {
+        return true;
+    }
+
+    char *error = NULL;
+    if (UNEXPECTED(!zend_is_callable_ex(callable,
+                                        /* object */ NULL,
+                                        /* check_flags */ 0,
+                                        /* callable_name */ NULL,
+                                        handler_fcc,
+                                        /* error */ &error))) {
+        if (!EG(exception)) {
+            zend_argument_type_error(
+                2 + !is_array_config, "must be a valid callback for option %s, %s", option_name, error);
+        }
+        efree(error);
+        return false;
+    }
+    zend_fcc_addref(handler_fcc);
+    return true;
+}
+
+#define HANDLE_CURL_OPTION_CALLABLE_PHP_CURL_USER(curl_ptr, constant_no_function, handler_type)                        \
+    case constant_no_function##FUNCTION: {                                                                             \
+        bool result = php_curl_set_callable_handler(                                                                   \
+            &curl_ptr->handlers.handler_type->fcc, zvalue, is_array_config, #constant_no_function "FUNCTION");         \
+        if (!result) {                                                                                                 \
+            return FAILURE;                                                                                            \
+        }                                                                                                              \
+        curl_ptr->handlers.handler_type->method = PHP_CURL_USER;                                                       \
+        break;                                                                                                         \
+    }
+
+#define HANDLE_CURL_OPTION_CALLABLE(curl_ptr, constant_no_function, handler_fcc, c_callback)                           \
+    case constant_no_function##FUNCTION: {                                                                             \
+        bool result = php_curl_set_callable_handler(                                                                   \
+            &curl_ptr->handler_fcc, zvalue, is_array_config, #constant_no_function "FUNCTION");                        \
+        if (!result) {                                                                                                 \
+            return FAILURE;                                                                                            \
+        }                                                                                                              \
+        curl_easy_setopt(curl_ptr->cp, constant_no_function##FUNCTION, (c_callback));                                  \
+        curl_easy_setopt(curl_ptr->cp, constant_no_function##DATA, curl_ptr);                                          \
+        break;                                                                                                         \
+    }
+
+static zend_result _php_curl_setopt(php_curl *ch, zend_long option, zval *zvalue, bool is_array_config) /* {{{ */
+{
+    CURLcode error = CURLE_OK;
+    zend_long lval;
+
+    switch (option) {
+        /* Callable options */
+        HANDLE_CURL_OPTION_CALLABLE_PHP_CURL_USER(ch, CURLOPT_WRITE, write);
+        HANDLE_CURL_OPTION_CALLABLE_PHP_CURL_USER(ch, CURLOPT_HEADER, write_header);
+        HANDLE_CURL_OPTION_CALLABLE_PHP_CURL_USER(ch, CURLOPT_READ, read);
+
+        HANDLE_CURL_OPTION_CALLABLE(ch, CURLOPT_PROGRESS, handlers.progress, fn_progress);
+        HANDLE_CURL_OPTION_CALLABLE(ch, CURLOPT_XFERINFO, handlers.xferinfo, fn_xferinfo);
+        HANDLE_CURL_OPTION_CALLABLE(ch, CURLOPT_FNMATCH_, handlers.fnmatch, fn_fnmatch);
+#if LIBCURL_VERSION_NUM >= 0x075400 /* Available since 7.84.0 */
+        HANDLE_CURL_OPTION_CALLABLE(ch, CURLOPT_SSH_HOSTKEY, handlers.sshhostkey, fn_ssh_hostkeyfunction);
+#endif
+
+    /* Long options */
+    case CURLOPT_SSL_VERIFYHOST:
+        lval = zval_get_long(zvalue);
+        if (lval == 1) {
+            php_error_docref(
+                NULL, E_NOTICE, "CURLOPT_SSL_VERIFYHOST no longer accepts the value 1, value 2 will be used instead");
+            error = curl_easy_setopt(ch->cp, (CURLoption) option, 2);
+            break;
+        }
+        ZEND_FALLTHROUGH;
+    case CURLOPT_AUTOREFERER:
+    case CURLOPT_BUFFERSIZE:
+    case CURLOPT_CONNECTTIMEOUT:
+    case CURLOPT_COOKIESESSION:
+    case CURLOPT_CRLF:
+    case CURLOPT_DNS_CACHE_TIMEOUT:
+    case CURLOPT_DNS_USE_GLOBAL_CACHE:
+    case CURLOPT_FAILONERROR:
+    case CURLOPT_FILETIME:
+    case CURLOPT_FORBID_REUSE:
+    case CURLOPT_FRESH_CONNECT:
+    case CURLOPT_FTP_USE_EPRT:
+    case CURLOPT_FTP_USE_EPSV:
+    case CURLOPT_HEADER:
+    case CURLOPT_HTTPGET:
+    case CURLOPT_HTTPPROXYTUNNEL:
+    case CURLOPT_HTTP_VERSION:
+    case CURLOPT_INFILESIZE:
+    case CURLOPT_LOW_SPEED_LIMIT:
+    case CURLOPT_LOW_SPEED_TIME:
+    case CURLOPT_MAXCONNECTS:
+    case CURLOPT_MAXREDIRS:
+    case CURLOPT_NETRC:
+    case CURLOPT_NOBODY:
+    case CURLOPT_NOPROGRESS:
+    case CURLOPT_NOSIGNAL:
+    case CURLOPT_PORT:
+    case CURLOPT_POST:
+    case CURLOPT_PROXYPORT:
+    case CURLOPT_PROXYTYPE:
+    case CURLOPT_PUT:
+    case CURLOPT_RESUME_FROM:
+    case CURLOPT_SSLVERSION:
+    case CURLOPT_SSL_VERIFYPEER:
+    case CURLOPT_TIMECONDITION:
+    case CURLOPT_TIMEOUT:
+    case CURLOPT_TIMEVALUE:
+    case CURLOPT_TRANSFERTEXT:
+    case CURLOPT_UNRESTRICTED_AUTH:
+    case CURLOPT_UPLOAD:
+    case CURLOPT_VERBOSE:
+    case CURLOPT_HTTPAUTH:
+    case CURLOPT_FTP_CREATE_MISSING_DIRS:
+    case CURLOPT_PROXYAUTH:
+    case CURLOPT_FTP_RESPONSE_TIMEOUT:
+    case CURLOPT_IPRESOLVE:
+    case CURLOPT_MAXFILESIZE:
+    case CURLOPT_TCP_NODELAY:
+    case CURLOPT_FTPSSLAUTH:
+    case CURLOPT_IGNORE_CONTENT_LENGTH:
+    case CURLOPT_FTP_SKIP_PASV_IP:
+    case CURLOPT_FTP_FILEMETHOD:
+    case CURLOPT_CONNECT_ONLY:
+    case CURLOPT_LOCALPORT:
+    case CURLOPT_LOCALPORTRANGE:
+    case CURLOPT_SSL_SESSIONID_CACHE:
+    case CURLOPT_FTP_SSL_CCC:
+    case CURLOPT_SSH_AUTH_TYPES:
+    case CURLOPT_CONNECTTIMEOUT_MS:
+    case CURLOPT_HTTP_CONTENT_DECODING:
+    case CURLOPT_HTTP_TRANSFER_DECODING:
+    case CURLOPT_TIMEOUT_MS:
+    case CURLOPT_NEW_DIRECTORY_PERMS:
+    case CURLOPT_NEW_FILE_PERMS:
+    case CURLOPT_USE_SSL:
+    case CURLOPT_APPEND:
+    case CURLOPT_DIRLISTONLY:
+    case CURLOPT_PROXY_TRANSFER_MODE:
+    case CURLOPT_ADDRESS_SCOPE:
+    case CURLOPT_CERTINFO:
+    case CURLOPT_PROTOCOLS:
+    case CURLOPT_REDIR_PROTOCOLS:
+    case CURLOPT_SOCKS5_GSSAPI_NEC:
+    case CURLOPT_TFTP_BLKSIZE:
+    case CURLOPT_FTP_USE_PRET:
+    case CURLOPT_RTSP_CLIENT_CSEQ:
+    case CURLOPT_RTSP_REQUEST:
+    case CURLOPT_RTSP_SERVER_CSEQ:
+    case CURLOPT_WILDCARDMATCH:
+    case CURLOPT_GSSAPI_DELEGATION:
+    case CURLOPT_ACCEPTTIMEOUT_MS:
+    case CURLOPT_SSL_OPTIONS:
+    case CURLOPT_TCP_KEEPALIVE:
+    case CURLOPT_TCP_KEEPIDLE:
+    case CURLOPT_TCP_KEEPINTVL:
+    case CURLOPT_SASL_IR:
+    case CURLOPT_EXPECT_100_TIMEOUT_MS:
+    case CURLOPT_SSL_ENABLE_ALPN:
+    case CURLOPT_SSL_ENABLE_NPN:
+    case CURLOPT_HEADEROPT:
+    case CURLOPT_SSL_VERIFYSTATUS:
+    case CURLOPT_PATH_AS_IS:
+    case CURLOPT_SSL_FALSESTART:
+    case CURLOPT_PIPEWAIT:
+    case CURLOPT_STREAM_WEIGHT:
+    case CURLOPT_TFTP_NO_OPTIONS:
+    case CURLOPT_TCP_FASTOPEN:
+    case CURLOPT_KEEP_SENDING_ON_ERROR:
+    case CURLOPT_PROXY_SSL_OPTIONS:
+    case CURLOPT_PROXY_SSL_VERIFYHOST:
+    case CURLOPT_PROXY_SSL_VERIFYPEER:
+    case CURLOPT_PROXY_SSLVERSION:
+    case CURLOPT_SUPPRESS_CONNECT_HEADERS:
+    case CURLOPT_SOCKS5_AUTH:
+    case CURLOPT_SSH_COMPRESSION:
+    case CURLOPT_HAPPY_EYEBALLS_TIMEOUT_MS:
+    case CURLOPT_DNS_SHUFFLE_ADDRESSES:
+    case CURLOPT_HAPROXYPROTOCOL:
+    case CURLOPT_DISALLOW_USERNAME_IN_URL:
+#if LIBCURL_VERSION_NUM >= 0x073E00 /* Available since 7.62.0 */
+    case CURLOPT_UPKEEP_INTERVAL_MS:
+    case CURLOPT_UPLOAD_BUFFERSIZE:
+#endif
+#if LIBCURL_VERSION_NUM >= 0x074000 /* Available since 7.64.0 */
+    case CURLOPT_HTTP09_ALLOWED:
+#endif
+#if LIBCURL_VERSION_NUM >= 0x074001 /* Available since 7.64.1 */
+    case CURLOPT_ALTSVC_CTRL:
+#endif
+#if LIBCURL_VERSION_NUM >= 0x074100 /* Available since 7.65.0 */
+    case CURLOPT_MAXAGE_CONN:
+#endif
+#if LIBCURL_VERSION_NUM >= 0x074500 /* Available since 7.69.0 */
+    case CURLOPT_MAIL_RCPT_ALLLOWFAILS:
+#endif
+#if LIBCURL_VERSION_NUM >= 0x074a00 /* Available since 7.74.0 */
+    case CURLOPT_HSTS_CTRL:
+#endif
+#if LIBCURL_VERSION_NUM >= 0x074c00 /* Available since 7.76.0 */
+    case CURLOPT_DOH_SSL_VERIFYHOST:
+    case CURLOPT_DOH_SSL_VERIFYPEER:
+    case CURLOPT_DOH_SSL_VERIFYSTATUS:
+#endif
+#if LIBCURL_VERSION_NUM >= 0x075000 /* Available since 7.80.0 */
+    case CURLOPT_MAXLIFETIME_CONN:
+#endif
+#if LIBCURL_VERSION_NUM >= 0x075100 /* Available since 7.81.0 */
+    case CURLOPT_MIME_OPTIONS:
+#endif
+#if LIBCURL_VERSION_NUM >= 0x075600 /* Available since 7.86.0 */
+    case CURLOPT_WS_OPTIONS:
+#endif
+#if LIBCURL_VERSION_NUM >= 0x075700 /* Available since 7.87.0 */
+    case CURLOPT_CA_CACHE_TIMEOUT:
+    case CURLOPT_QUICK_EXIT:
+#endif
+#if LIBCURL_VERSION_NUM >= 0x080900 /* Available since 8.9.0 */
+    case CURLOPT_TCP_KEEPCNT:
+#endif
+        lval = zval_get_long(zvalue);
+        if ((option == CURLOPT_PROTOCOLS || option == CURLOPT_REDIR_PROTOCOLS) &&
+            (PG(open_basedir) && *PG(open_basedir)) && (lval & CURLPROTO_FILE)) {
+            php_error_docref(NULL, E_WARNING, "CURLPROTO_FILE cannot be activated when an open_basedir is set");
+            return FAILURE;
+        }
+#if defined(ZTS)
+        if (option == CURLOPT_DNS_USE_GLOBAL_CACHE && lval) {
+            php_error_docref(
+                NULL, E_WARNING, "CURLOPT_DNS_USE_GLOBAL_CACHE cannot be activated when thread safety is enabled");
+            return FAILURE;
+        }
+#endif
+        error = curl_easy_setopt(ch->cp, (CURLoption) option, lval);
+        break;
+    case CURLOPT_SAFE_UPLOAD:
+        if (!zend_is_true(zvalue)) {
+            zend_value_error("%s(): Disabling safe uploads is no longer supported", get_active_function_name());
+            return FAILURE;
+        }
+        break;
+
+    /* String options */
+    case CURLOPT_CAINFO:
+    case CURLOPT_CAPATH:
+    case CURLOPT_COOKIE:
+    case CURLOPT_EGDSOCKET:
+    case CURLOPT_INTERFACE:
+    case CURLOPT_PROXY:
+    case CURLOPT_PROXYUSERPWD:
+    case CURLOPT_REFERER:
+    case CURLOPT_SSLCERTTYPE:
+    case CURLOPT_SSLENGINE:
+    case CURLOPT_SSLENGINE_DEFAULT:
+    case CURLOPT_SSLKEY:
+    case CURLOPT_SSLKEYPASSWD:
+    case CURLOPT_SSLKEYTYPE:
+    case CURLOPT_SSL_CIPHER_LIST:
+    case CURLOPT_USERAGENT:
+    case CURLOPT_USERPWD:
+    case CURLOPT_COOKIELIST:
+    case CURLOPT_FTP_ALTERNATIVE_TO_USER:
+    case CURLOPT_SSH_HOST_PUBLIC_KEY_MD5:
+    case CURLOPT_PASSWORD:
+    case CURLOPT_PROXYPASSWORD:
+    case CURLOPT_PROXYUSERNAME:
+    case CURLOPT_USERNAME:
+    case CURLOPT_NOPROXY:
+    case CURLOPT_SOCKS5_GSSAPI_SERVICE:
+    case CURLOPT_MAIL_FROM:
+    case CURLOPT_RTSP_STREAM_URI:
+    case CURLOPT_RTSP_TRANSPORT:
+    case CURLOPT_TLSAUTH_TYPE:
+    case CURLOPT_TLSAUTH_PASSWORD:
+    case CURLOPT_TLSAUTH_USERNAME:
+    case CURLOPT_TRANSFER_ENCODING:
+    case CURLOPT_DNS_SERVERS:
+    case CURLOPT_MAIL_AUTH:
+    case CURLOPT_LOGIN_OPTIONS:
+    case CURLOPT_PINNEDPUBLICKEY:
+    case CURLOPT_PROXY_SERVICE_NAME:
+    case CURLOPT_SERVICE_NAME:
+    case CURLOPT_DEFAULT_PROTOCOL:
+    case CURLOPT_PRE_PROXY:
+    case CURLOPT_PROXY_CAINFO:
+    case CURLOPT_PROXY_CAPATH:
+    case CURLOPT_PROXY_CRLFILE:
+    case CURLOPT_PROXY_KEYPASSWD:
+    case CURLOPT_PROXY_PINNEDPUBLICKEY:
+    case CURLOPT_PROXY_SSL_CIPHER_LIST:
+    case CURLOPT_PROXY_SSLCERT:
+    case CURLOPT_PROXY_SSLCERTTYPE:
+    case CURLOPT_PROXY_SSLKEY:
+    case CURLOPT_PROXY_SSLKEYTYPE:
+    case CURLOPT_PROXY_TLSAUTH_PASSWORD:
+    case CURLOPT_PROXY_TLSAUTH_TYPE:
+    case CURLOPT_PROXY_TLSAUTH_USERNAME:
+    case CURLOPT_ABSTRACT_UNIX_SOCKET:
+    case CURLOPT_REQUEST_TARGET:
+    case CURLOPT_PROXY_TLS13_CIPHERS:
+    case CURLOPT_TLS13_CIPHERS:
+#if LIBCURL_VERSION_NUM >= 0x074001 /* Available since 7.64.1 */
+    case CURLOPT_ALTSVC:
+#endif
+#if LIBCURL_VERSION_NUM >= 0x074200 /* Available since 7.66.0 */
+    case CURLOPT_SASL_AUTHZID:
+#endif
+#if LIBCURL_VERSION_NUM >= 0x074700 /* Available since 7.71.0 */
+    case CURLOPT_PROXY_ISSUERCERT:
+#endif
+#if LIBCURL_VERSION_NUM >= 0x074900 /* Available since 7.73.0 */
+    case CURLOPT_SSL_EC_CURVES:
+#endif
+#if LIBCURL_VERSION_NUM >= 0x074b00 /* Available since 7.75.0 */
+    case CURLOPT_AWS_SIGV4:
+#endif
+#if LIBCURL_VERSION_NUM >= 0x075000 /* Available since 7.80.0 */
+    case CURLOPT_SSH_HOST_PUBLIC_KEY_SHA256:
+#endif
+#if LIBCURL_VERSION_NUM >= 0x075500 /* Available since 7.85.0 */
+    case CURLOPT_PROTOCOLS_STR:
+    case CURLOPT_REDIR_PROTOCOLS_STR:
+#endif
+    {
+        zend_string *tmp_str;
+        zend_string *str = zval_get_tmp_string(zvalue, &tmp_str);
+#if LIBCURL_VERSION_NUM >= 0x075500 /* Available since 7.85.0 */
+        if ((option == CURLOPT_PROTOCOLS_STR || option == CURLOPT_REDIR_PROTOCOLS_STR) &&
+            (PG(open_basedir) && *PG(open_basedir)) &&
+            php_memnistr(ZSTR_VAL(str), "file", sizeof("file") - 1, ZSTR_VAL(str) + ZSTR_LEN(str)) != NULL) {
+            php_error_docref(NULL, E_WARNING, "The FILE protocol cannot be activated when an open_basedir is set");
+            return FAILURE;
+        }
+#endif
+        zend_result ret = php_curl_option_str(ch, option, ZSTR_VAL(str), ZSTR_LEN(str));
+        zend_tmp_string_release(tmp_str);
+        return ret;
+    }
+
+    /* Curl nullable string options */
+    case CURLOPT_CUSTOMREQUEST:
+    case CURLOPT_FTPPORT:
+    case CURLOPT_RANGE:
+    case CURLOPT_FTP_ACCOUNT:
+    case CURLOPT_RTSP_SESSION_ID:
+    case CURLOPT_ACCEPT_ENCODING:
+    case CURLOPT_DNS_INTERFACE:
+    case CURLOPT_DNS_LOCAL_IP4:
+    case CURLOPT_DNS_LOCAL_IP6:
+    case CURLOPT_XOAUTH2_BEARER:
+    case CURLOPT_UNIX_SOCKET_PATH:
+#if LIBCURL_VERSION_NUM >= 0x073E00 /* Available since 7.62.0 */
+    case CURLOPT_DOH_URL:
+#endif
+#if LIBCURL_VERSION_NUM >= 0x074a00 /* Available since 7.74.0 */
+    case CURLOPT_HSTS:
+#endif
+    case CURLOPT_KRBLEVEL: {
+        if (Z_ISNULL_P(zvalue)) {
+            error = curl_easy_setopt(ch->cp, (CURLoption) option, NULL);
+        } else {
+            zend_string *tmp_str;
+            zend_string *str = zval_get_tmp_string(zvalue, &tmp_str);
+            zend_result ret = php_curl_option_str(ch, option, ZSTR_VAL(str), ZSTR_LEN(str));
+            zend_tmp_string_release(tmp_str);
+            return ret;
+        }
+        break;
+    }
+
+    /* Curl private option */
+    case CURLOPT_PRIVATE: {
+        zval_ptr_dtor(&ch->private_data);
+        ZVAL_COPY(&ch->private_data, zvalue);
+        return SUCCESS;
+    }
+
+    /* Curl url option */
+    case CURLOPT_URL: {
+        zend_string *tmp_str;
+        zend_string *str = zval_get_tmp_string(zvalue, &tmp_str);
+        zend_result ret = php_curl_option_url(ch, str);
+        zend_tmp_string_release(tmp_str);
+        return ret;
+    }
+
+    /* Curl file handle options */
+    case CURLOPT_FILE:
+    case CURLOPT_INFILE:
+    case CURLOPT_STDERR:
+    case CURLOPT_WRITEHEADER: {
+        FILE *fp = NULL;
+        php_stream *what = NULL;
+
+        if (Z_TYPE_P(zvalue) != IS_NULL) {
+            what = (php_stream *) zend_fetch_resource2_ex(
+                zvalue, "File-Handle", php_file_le_stream(), php_file_le_pstream());
+            if (!what) {
+                return FAILURE;
+            }
+
+            if (FAILURE == php_stream_cast(what, PHP_STREAM_AS_STDIO, (void **) &fp, REPORT_ERRORS)) {
+                return FAILURE;
+            }
+
+            if (!fp) {
+                return FAILURE;
+            }
+        }
+
+        error = CURLE_OK;
+        switch (option) {
+        case CURLOPT_FILE:
+            if (!what) {
+                if (!Z_ISUNDEF(ch->handlers.write->stream)) {
+                    zval_ptr_dtor(&ch->handlers.write->stream);
+                    ZVAL_UNDEF(&ch->handlers.write->stream);
+                }
+                ch->handlers.write->fp = NULL;
+                ch->handlers.write->method = PHP_CURL_STDOUT;
+            } else if (what->mode[0] != 'r' || what->mode[1] == '+') {
+                zval_ptr_dtor(&ch->handlers.write->stream);
+                ch->handlers.write->fp = fp;
+                ch->handlers.write->method = PHP_CURL_FILE;
+                ZVAL_COPY(&ch->handlers.write->stream, zvalue);
+            } else {
+                zend_value_error("%s(): The provided file handle must be writable", get_active_function_name());
+                return FAILURE;
+            }
+            break;
+        case CURLOPT_WRITEHEADER:
+            if (!what) {
+                if (!Z_ISUNDEF(ch->handlers.write_header->stream)) {
+                    zval_ptr_dtor(&ch->handlers.write_header->stream);
+                    ZVAL_UNDEF(&ch->handlers.write_header->stream);
+                }
+                ch->handlers.write_header->fp = NULL;
+                ch->handlers.write_header->method = PHP_CURL_IGNORE;
+            } else if (what->mode[0] != 'r' || what->mode[1] == '+') {
+                zval_ptr_dtor(&ch->handlers.write_header->stream);
+                ch->handlers.write_header->fp = fp;
+                ch->handlers.write_header->method = PHP_CURL_FILE;
+                ZVAL_COPY(&ch->handlers.write_header->stream, zvalue);
+            } else {
+                zend_value_error("%s(): The provided file handle must be writable", get_active_function_name());
+                return FAILURE;
+            }
+            break;
+        case CURLOPT_INFILE:
+            if (!what) {
+                if (!Z_ISUNDEF(ch->handlers.read->stream)) {
+                    zval_ptr_dtor(&ch->handlers.read->stream);
+                    ZVAL_UNDEF(&ch->handlers.read->stream);
+                }
+                ch->handlers.read->fp = NULL;
+                ch->handlers.read->res = NULL;
+            } else {
+                zval_ptr_dtor(&ch->handlers.read->stream);
+                ch->handlers.read->fp = fp;
+                ch->handlers.read->res = Z_RES_P(zvalue);
+                ZVAL_COPY(&ch->handlers.read->stream, zvalue);
+            }
+            break;
+        case CURLOPT_STDERR:
+            if (!what) {
+                if (!Z_ISUNDEF(ch->handlers.std_err)) {
+                    zval_ptr_dtor(&ch->handlers.std_err);
+                    ZVAL_UNDEF(&ch->handlers.std_err);
+                }
+            } else if (what->mode[0] != 'r' || what->mode[1] == '+') {
+                zval_ptr_dtor(&ch->handlers.std_err);
+                ZVAL_COPY(&ch->handlers.std_err, zvalue);
+            } else {
+                zend_value_error("%s(): The provided file handle must be writable", get_active_function_name());
+                return FAILURE;
+            }
+            ZEND_FALLTHROUGH;
+        default:
+            error = curl_easy_setopt(ch->cp, (CURLoption) option, fp);
+            break;
+        }
+        break;
+    }
+
+    /* Curl linked list options */
+    case CURLOPT_HTTP200ALIASES:
+    case CURLOPT_HTTPHEADER:
+    case CURLOPT_POSTQUOTE:
+    case CURLOPT_PREQUOTE:
+    case CURLOPT_QUOTE:
+    case CURLOPT_TELNETOPTIONS:
+    case CURLOPT_MAIL_RCPT:
+    case CURLOPT_RESOLVE:
+    case CURLOPT_PROXYHEADER:
+    case CURLOPT_CONNECT_TO: {
+        zval *current;
+        HashTable *ph;
+        zend_string *val, *tmp_val;
+        struct curl_slist *slist = NULL;
+
+        if (Z_TYPE_P(zvalue) != IS_ARRAY) {
+            const char *name = NULL;
+            switch (option) {
+            case CURLOPT_HTTPHEADER:
+                name = "CURLOPT_HTTPHEADER";
+                break;
+            case CURLOPT_QUOTE:
+                name = "CURLOPT_QUOTE";
+                break;
+            case CURLOPT_HTTP200ALIASES:
+                name = "CURLOPT_HTTP200ALIASES";
+                break;
+            case CURLOPT_POSTQUOTE:
+                name = "CURLOPT_POSTQUOTE";
+                break;
+            case CURLOPT_PREQUOTE:
+                name = "CURLOPT_PREQUOTE";
+                break;
+            case CURLOPT_TELNETOPTIONS:
+                name = "CURLOPT_TELNETOPTIONS";
+                break;
+            case CURLOPT_MAIL_RCPT:
+                name = "CURLOPT_MAIL_RCPT";
+                break;
+            case CURLOPT_RESOLVE:
+                name = "CURLOPT_RESOLVE";
+                break;
+            case CURLOPT_PROXYHEADER:
+                name = "CURLOPT_PROXYHEADER";
+                break;
+            case CURLOPT_CONNECT_TO:
+                name = "CURLOPT_CONNECT_TO";
+                break;
+            }
+
+            zend_type_error("%s(): The %s option must have an array value", get_active_function_name(), name);
+            return FAILURE;
+        }
+
+        ph = Z_ARRVAL_P(zvalue);
+        ZEND_HASH_FOREACH_VAL(ph, current) {
+            ZVAL_DEREF(current);
+            val = zval_get_tmp_string(current, &tmp_val);
+            slist = curl_slist_append(slist, ZSTR_VAL(val));
+            zend_tmp_string_release(tmp_val);
+            if (!slist) {
+                php_error_docref(NULL, E_WARNING, "Could not build curl_slist");
+                return FAILURE;
+            }
+        }
+        ZEND_HASH_FOREACH_END();
+
+        if (slist) {
+            if ((*ch->clone) == 1) {
+                zend_hash_index_update_ptr(ch->to_free->slist, option, slist);
+            } else {
+                zend_hash_next_index_insert_ptr(ch->to_free->slist, slist);
+            }
+        }
+
+        error = curl_easy_setopt(ch->cp, (CURLoption) option, slist);
+
+        break;
+    }
+
+    case CURLOPT_BINARYTRANSFER:
+        /* Do nothing, just backward compatibility */
+        break;
+
+    case CURLOPT_FOLLOWLOCATION:
+        lval = zend_is_true(zvalue);
+        error = curl_easy_setopt(ch->cp, (CURLoption) option, lval);
+        break;
+
+    case CURLOPT_POSTFIELDS:
+        if (Z_TYPE_P(zvalue) == IS_ARRAY) {
+            if (zend_hash_num_elements(HASH_OF(zvalue)) == 0) {
+                /* no need to build the mime structure for empty hashtables;
+                   also works around https://github.com/curl/curl/issues/6455 */
+                curl_easy_setopt(ch->cp, CURLOPT_POSTFIELDS, "");
+                error = curl_easy_setopt(ch->cp, CURLOPT_POSTFIELDSIZE, 0);
+            } else {
+                return build_mime_structure_from_hash(ch, zvalue);
+            }
+        } else {
+            zend_string *tmp_str;
+            zend_string *str = zval_get_tmp_string(zvalue, &tmp_str);
+            /* with curl 7.17.0 and later, we can use COPYPOSTFIELDS, but we have to provide size before */
+            error = curl_easy_setopt(ch->cp, CURLOPT_POSTFIELDSIZE, ZSTR_LEN(str));
+            error = curl_easy_setopt(ch->cp, CURLOPT_COPYPOSTFIELDS, ZSTR_VAL(str));
+            zend_tmp_string_release(tmp_str);
+        }
+        break;
+
+    case CURLOPT_RETURNTRANSFER:
+        if (zend_is_true(zvalue)) {
+            ch->handlers.write->method = PHP_CURL_RETURN;
+        } else {
+            ch->handlers.write->method = PHP_CURL_STDOUT;
+        }
+        break;
+
+    /* Curl off_t options */
+    case CURLOPT_MAX_RECV_SPEED_LARGE:
+    case CURLOPT_MAX_SEND_SPEED_LARGE:
+    case CURLOPT_MAXFILESIZE_LARGE:
+    case CURLOPT_TIMEVALUE_LARGE:
+        lval = zval_get_long(zvalue);
+        error = curl_easy_setopt(ch->cp, (CURLoption) option, (curl_off_t) lval);
+        break;
+
+    case CURLOPT_POSTREDIR:
+        lval = zval_get_long(zvalue);
+        error = curl_easy_setopt(ch->cp, CURLOPT_POSTREDIR, lval & CURL_REDIR_POST_ALL);
+        break;
+
+    /* the following options deal with files, therefore the open_basedir check
+     * is required.
+     */
+    case CURLOPT_COOKIEFILE:
+    case CURLOPT_COOKIEJAR:
+    case CURLOPT_RANDOM_FILE:
+    case CURLOPT_SSLCERT:
+    case CURLOPT_NETRC_FILE:
+    case CURLOPT_SSH_PRIVATE_KEYFILE:
+    case CURLOPT_SSH_PUBLIC_KEYFILE:
+    case CURLOPT_CRLFILE:
+    case CURLOPT_ISSUERCERT:
+    case CURLOPT_SSH_KNOWNHOSTS: {
+        zend_string *tmp_str;
+        zend_string *str = zval_get_tmp_string(zvalue, &tmp_str);
+        zend_result ret;
+
+        if (ZSTR_LEN(str) && php_check_open_basedir(ZSTR_VAL(str))) {
+            zend_tmp_string_release(tmp_str);
+            return FAILURE;
+        }
+
+        ret = php_curl_option_str(ch, option, ZSTR_VAL(str), ZSTR_LEN(str));
+        zend_tmp_string_release(tmp_str);
+        return ret;
+    }
+
+    case CURLINFO_HEADER_OUT:
+        if (zend_is_true(zvalue)) {
+            curl_easy_setopt(ch->cp, CURLOPT_DEBUGFUNCTION, curl_debug);
+            curl_easy_setopt(ch->cp, CURLOPT_DEBUGDATA, (void *) ch);
+            curl_easy_setopt(ch->cp, CURLOPT_VERBOSE, 1);
+        } else {
+            curl_easy_setopt(ch->cp, CURLOPT_DEBUGFUNCTION, NULL);
+            curl_easy_setopt(ch->cp, CURLOPT_DEBUGDATA, NULL);
+            curl_easy_setopt(ch->cp, CURLOPT_VERBOSE, 0);
+        }
+        break;
+
+    case CURLOPT_SHARE: {
+        if (Z_TYPE_P(zvalue) == IS_OBJECT && Z_OBJCE_P(zvalue) == curl_share_ce) {
+            php_curlsh *sh = Z_CURL_SHARE_P(zvalue);
+            curl_easy_setopt(ch->cp, CURLOPT_SHARE, sh->share);
+
+            if (ch->share) {
+                OBJ_RELEASE(&ch->share->std);
+            }
+            GC_ADDREF(&sh->std);
+            ch->share = sh;
+        }
+    } break;
+
+    /* Curl blob options */
+#if LIBCURL_VERSION_NUM >= 0x074700 /* Available since 7.71.0 */
+    case CURLOPT_ISSUERCERT_BLOB:
+    case CURLOPT_PROXY_ISSUERCERT_BLOB:
+    case CURLOPT_PROXY_SSLCERT_BLOB:
+    case CURLOPT_PROXY_SSLKEY_BLOB:
+    case CURLOPT_SSLCERT_BLOB:
+    case CURLOPT_SSLKEY_BLOB:
+#if LIBCURL_VERSION_NUM >= 0x074d00 /* Available since 7.77.0 */
+    case CURLOPT_CAINFO_BLOB:
+    case CURLOPT_PROXY_CAINFO_BLOB:
+#endif
+    {
+        zend_string *tmp_str;
+        zend_string *str = zval_get_tmp_string(zvalue, &tmp_str);
+
+        struct curl_blob stblob;
+        stblob.data = ZSTR_VAL(str);
+        stblob.len = ZSTR_LEN(str);
+        stblob.flags = CURL_BLOB_COPY;
+        error = curl_easy_setopt(ch->cp, (CURLoption) option, &stblob);
+
+        zend_tmp_string_release(tmp_str);
+    } break;
+#endif
+
+    default:
+        if (is_array_config) {
+            zend_argument_value_error(2, "must contain only valid cURL options");
+        } else {
+            zend_argument_value_error(2, "is not a valid cURL option");
+        }
+        error = CURLE_UNKNOWN_OPTION;
+        break;
+    }
+
+    SAVE_CURL_ERROR(ch, error);
+    if (error != CURLE_OK) {
+        return FAILURE;
+    } else {
+        return SUCCESS;
+    }
+}
+/* }}} */
+
+/* {{{ Set an option for a cURL transfer */
+PHP_FUNCTION(swoole_native_curl_setopt) {
+    zval *zid, *zvalue;
+    zend_long options;
+    php_curl *ch;
+
+    ZEND_PARSE_PARAMETERS_START(3, 3)
+    Z_PARAM_OBJECT_OF_CLASS(zid, curl_ce)
+    Z_PARAM_LONG(options)
+    Z_PARAM_ZVAL(zvalue)
+    ZEND_PARSE_PARAMETERS_END();
+
+    if ((ch = swoole_curl_get_handle(zid)) == NULL) {
+        RETURN_FALSE;
+    }
+
+    if (_php_curl_setopt(ch, options, zvalue, 0) == SUCCESS) {
+        RETURN_TRUE;
+    } else {
+        RETURN_FALSE;
+    }
+}
+/* }}} */
+
+/* {{{ Set an array of option for a cURL transfer */
+PHP_FUNCTION(swoole_native_curl_setopt_array) {
+    zval *zid, *arr, *entry;
+    php_curl *ch;
+    zend_ulong option;
+    zend_string *string_key;
+
+    ZEND_PARSE_PARAMETERS_START(2, 2)
+    Z_PARAM_OBJECT_OF_CLASS(zid, swoole_coroutine_curl_handle_ce)
+    Z_PARAM_ARRAY(arr)
+    ZEND_PARSE_PARAMETERS_END();
+
+    if ((ch = swoole_curl_get_handle(zid)) == NULL) {
+        RETURN_FALSE;
+    }
+
+    ZEND_HASH_FOREACH_KEY_VAL(Z_ARRVAL_P(arr), option, string_key, entry) {
+        if (string_key) {
+            zend_argument_value_error(2, "contains an invalid cURL option");
+            RETURN_THROWS();
+        }
+
+        ZVAL_DEREF(entry);
+        if (_php_curl_setopt(ch, (zend_long) option, entry, 1) == FAILURE) {
+            RETURN_FALSE;
+        }
+    }
+    ZEND_HASH_FOREACH_END();
+
+    RETURN_TRUE;
+}
+/* }}} */
+
+/* {{{ _php_curl_cleanup_handle(ch)
+   Cleanup an execution phase */
+void swoole_curl_cleanup_handle(php_curl *ch) {
+    smart_str_free(&ch->handlers.write->buf);
+    if (ch->header.str) {
+        zend_string_release_ex(ch->header.str, 0);
+        ch->header.str = NULL;
+    }
+
+    memset(ch->err.str, 0, CURL_ERROR_SIZE + 1);
+    ch->err.no = 0;
+}
+/* }}} */
+
+/* {{{ Perform a cURL session */
+PHP_FUNCTION(swoole_native_curl_exec) {
+    CURLcode error;
+    zval *zid;
+    php_curl *ch;
+
+    ZEND_PARSE_PARAMETERS_START(1, 1)
+    Z_PARAM_OBJECT_OF_CLASS(zid, swoole_coroutine_curl_handle_ce)
+    ZEND_PARSE_PARAMETERS_END();
+
+    if ((ch = swoole_curl_get_handle(zid)) == NULL) {
+        RETURN_FALSE;
+    }
+
+    swoole_curl_verify_handlers(ch, 1);
+
+    swoole_curl_cleanup_handle(ch);
+
+    Multi *multi = new Multi();
+    error = multi->exec(swoole::curl::get_handle(ch->cp));
+    delete multi;
+    SAVE_CURL_ERROR(ch, error);
+
+    if (error != CURLE_OK) {
+        smart_str_free(&ch->handlers.write->buf);
+        RETURN_FALSE;
+    }
+
+    if (!Z_ISUNDEF(ch->handlers.std_err)) {
+        php_stream *stream;
+        stream = (php_stream *) zend_fetch_resource2_ex(
+            &ch->handlers.std_err, NULL, php_file_le_stream(), php_file_le_pstream());
+        if (stream) {
+            php_stream_flush(stream);
+        }
+    }
+
+    if (ch->handlers.write->method == PHP_CURL_RETURN && ch->handlers.write->buf.s) {
+        smart_str_0(&ch->handlers.write->buf);
+        RETURN_STR_COPY(ch->handlers.write->buf.s);
+    }
+
+    /* flush the file handle, so any remaining data is synched to disk */
+    if (ch->handlers.write->method == PHP_CURL_FILE && ch->handlers.write->fp) {
+        fflush(ch->handlers.write->fp);
+    }
+    if (ch->handlers.write_header->method == PHP_CURL_FILE && ch->handlers.write_header->fp) {
+        fflush(ch->handlers.write_header->fp);
+    }
+
+    if (ch->handlers.write->method == PHP_CURL_RETURN) {
+        RETURN_EMPTY_STRING();
+    } else {
+        RETURN_TRUE;
+    }
+}
+/* }}} */
+
+/* {{{ Get information regarding a specific transfer */
+PHP_FUNCTION(swoole_native_curl_getinfo) {
+    zval *zid;
+    php_curl *ch;
+    zend_long option;
+    bool option_is_null = 1;
+
+    ZEND_PARSE_PARAMETERS_START(1, 2)
+    Z_PARAM_OBJECT_OF_CLASS(zid, swoole_coroutine_curl_handle_ce)
+    Z_PARAM_OPTIONAL
+    Z_PARAM_LONG_OR_NULL(option, option_is_null)
+    ZEND_PARSE_PARAMETERS_END();
+
+    if ((ch = swoole_curl_get_handle(zid)) == NULL) {
+        RETURN_FALSE;
+    }
+
+    if (option_is_null) {
+        char *s_code;
+        /* libcurl expects long datatype. So far no cases are known where
+           it would be an issue. Using zend_long would truncate a 64-bit
+           var on Win64, so the exact long datatype fits everywhere, as
+           long as there's no 32-bit int overflow. */
+        long l_code;
+        double d_code;
+        struct curl_certinfo *ci = NULL;
+        zval listcode;
+        curl_off_t co;
+
+        array_init(return_value);
+
+        if (curl_easy_getinfo(ch->cp, CURLINFO_EFFECTIVE_URL, &s_code) == CURLE_OK) {
+            CAAS("url", s_code);
+        }
+        if (curl_easy_getinfo(ch->cp, CURLINFO_CONTENT_TYPE, &s_code) == CURLE_OK) {
+            if (s_code != NULL) {
+                CAAS("content_type", s_code);
+            } else {
+                zval retnull;
+                ZVAL_NULL(&retnull);
+                CAAZ("content_type", &retnull);
+            }
+        }
+        if (curl_easy_getinfo(ch->cp, CURLINFO_HTTP_CODE, &l_code) == CURLE_OK) {
+            CAAL("http_code", l_code);
+        }
+        if (curl_easy_getinfo(ch->cp, CURLINFO_HEADER_SIZE, &l_code) == CURLE_OK) {
+            CAAL("header_size", l_code);
+        }
+        if (curl_easy_getinfo(ch->cp, CURLINFO_REQUEST_SIZE, &l_code) == CURLE_OK) {
+            CAAL("request_size", l_code);
+        }
+        if (curl_easy_getinfo(ch->cp, CURLINFO_FILETIME, &l_code) == CURLE_OK) {
+            CAAL("filetime", l_code);
+        }
+        if (curl_easy_getinfo(ch->cp, CURLINFO_SSL_VERIFYRESULT, &l_code) == CURLE_OK) {
+            CAAL("ssl_verify_result", l_code);
+        }
+        if (curl_easy_getinfo(ch->cp, CURLINFO_REDIRECT_COUNT, &l_code) == CURLE_OK) {
+            CAAL("redirect_count", l_code);
+        }
+        if (curl_easy_getinfo(ch->cp, CURLINFO_TOTAL_TIME, &d_code) == CURLE_OK) {
+            CAAD("total_time", d_code);
+        }
+        if (curl_easy_getinfo(ch->cp, CURLINFO_NAMELOOKUP_TIME, &d_code) == CURLE_OK) {
+            CAAD("namelookup_time", d_code);
+        }
+        if (curl_easy_getinfo(ch->cp, CURLINFO_CONNECT_TIME, &d_code) == CURLE_OK) {
+            CAAD("connect_time", d_code);
+        }
+        if (curl_easy_getinfo(ch->cp, CURLINFO_PRETRANSFER_TIME, &d_code) == CURLE_OK) {
+            CAAD("pretransfer_time", d_code);
+        }
+        if (curl_easy_getinfo(ch->cp, CURLINFO_SIZE_UPLOAD, &d_code) == CURLE_OK) {
+            CAAD("size_upload", d_code);
+        }
+        if (curl_easy_getinfo(ch->cp, CURLINFO_SIZE_DOWNLOAD, &d_code) == CURLE_OK) {
+            CAAD("size_download", d_code);
+        }
+        if (curl_easy_getinfo(ch->cp, CURLINFO_SPEED_DOWNLOAD, &d_code) == CURLE_OK) {
+            CAAD("speed_download", d_code);
+        }
+        if (curl_easy_getinfo(ch->cp, CURLINFO_SPEED_UPLOAD, &d_code) == CURLE_OK) {
+            CAAD("speed_upload", d_code);
+        }
+        if (curl_easy_getinfo(ch->cp, CURLINFO_CONTENT_LENGTH_DOWNLOAD, &d_code) == CURLE_OK) {
+            CAAD("download_content_length", d_code);
+        }
+        if (curl_easy_getinfo(ch->cp, CURLINFO_CONTENT_LENGTH_UPLOAD, &d_code) == CURLE_OK) {
+            CAAD("upload_content_length", d_code);
+        }
+        if (curl_easy_getinfo(ch->cp, CURLINFO_STARTTRANSFER_TIME, &d_code) == CURLE_OK) {
+            CAAD("starttransfer_time", d_code);
+        }
+        if (curl_easy_getinfo(ch->cp, CURLINFO_REDIRECT_TIME, &d_code) == CURLE_OK) {
+            CAAD("redirect_time", d_code);
+        }
+        if (curl_easy_getinfo(ch->cp, CURLINFO_REDIRECT_URL, &s_code) == CURLE_OK) {
+            CAAS("redirect_url", s_code);
+        }
+        if (curl_easy_getinfo(ch->cp, CURLINFO_PRIMARY_IP, &s_code) == CURLE_OK) {
+            CAAS("primary_ip", s_code);
+        }
+        if (curl_easy_getinfo(ch->cp, CURLINFO_CERTINFO, &ci) == CURLE_OK) {
+            array_init(&listcode);
+            create_certinfo(ci, &listcode);
+            CAAZ("certinfo", &listcode);
+        }
+        if (curl_easy_getinfo(ch->cp, CURLINFO_PRIMARY_PORT, &l_code) == CURLE_OK) {
+            CAAL("primary_port", l_code);
+        }
+        if (curl_easy_getinfo(ch->cp, CURLINFO_LOCAL_IP, &s_code) == CURLE_OK) {
+            CAAS("local_ip", s_code);
+        }
+        if (curl_easy_getinfo(ch->cp, CURLINFO_LOCAL_PORT, &l_code) == CURLE_OK) {
+            CAAL("local_port", l_code);
+        }
+        if (curl_easy_getinfo(ch->cp, CURLINFO_HTTP_VERSION, &l_code) == CURLE_OK) {
+            CAAL("http_version", l_code);
+        }
+        if (curl_easy_getinfo(ch->cp, CURLINFO_PROTOCOL, &l_code) == CURLE_OK) {
+            CAAL("protocol", l_code);
+        }
+        if (curl_easy_getinfo(ch->cp, CURLINFO_PROXY_SSL_VERIFYRESULT, &l_code) == CURLE_OK) {
+            CAAL("ssl_verifyresult", l_code);
+        }
+        if (curl_easy_getinfo(ch->cp, CURLINFO_SCHEME, &s_code) == CURLE_OK) {
+            CAAS("scheme", s_code);
+        }
+        if (curl_easy_getinfo(ch->cp, CURLINFO_APPCONNECT_TIME_T, &co) == CURLE_OK) {
+            CAAL("appconnect_time_us", co);
+        }
+        if (curl_easy_getinfo(ch->cp, CURLINFO_CONNECT_TIME_T, &co) == CURLE_OK) {
+            CAAL("connect_time_us", co);
+        }
+        if (curl_easy_getinfo(ch->cp, CURLINFO_NAMELOOKUP_TIME_T, &co) == CURLE_OK) {
+            CAAL("namelookup_time_us", co);
+        }
+        if (curl_easy_getinfo(ch->cp, CURLINFO_PRETRANSFER_TIME_T, &co) == CURLE_OK) {
+            CAAL("pretransfer_time_us", co);
+        }
+        if (curl_easy_getinfo(ch->cp, CURLINFO_REDIRECT_TIME_T, &co) == CURLE_OK) {
+            CAAL("redirect_time_us", co);
+        }
+        if (curl_easy_getinfo(ch->cp, CURLINFO_STARTTRANSFER_TIME_T, &co) == CURLE_OK) {
+            CAAL("starttransfer_time_us", co);
+        }
+        if (curl_easy_getinfo(ch->cp, CURLINFO_TOTAL_TIME_T, &co) == CURLE_OK) {
+            CAAL("total_time_us", co);
+        }
+        if (ch->header.str) {
+            CAASTR("request_header", ch->header.str);
+        }
+#if LIBCURL_VERSION_NUM >= 0x074800 /* Available since 7.72.0 */
+        if (curl_easy_getinfo(ch->cp, CURLINFO_EFFECTIVE_METHOD, &s_code) == CURLE_OK) {
+            CAAS("effective_method", s_code);
+        }
+#endif
+#if LIBCURL_VERSION_NUM >= 0x075400 /* Available since 7.84.0 */
+        if (curl_easy_getinfo(ch->cp, CURLINFO_CAPATH, &s_code) == CURLE_OK) {
+            CAAS("capath", s_code);
+        }
+        if (curl_easy_getinfo(ch->cp, CURLINFO_CAINFO, &s_code) == CURLE_OK) {
+            CAAS("cainfo", s_code);
+        }
+#endif
+    } else {
+        switch (option) {
+        case CURLINFO_HEADER_OUT:
+            if (ch->header.str) {
+                RETURN_STR_COPY(ch->header.str);
+            } else {
+                RETURN_FALSE;
+            }
+        case CURLINFO_CERTINFO: {
+            struct curl_certinfo *ci = NULL;
+
+            array_init(return_value);
+
+            if (curl_easy_getinfo(ch->cp, CURLINFO_CERTINFO, &ci) == CURLE_OK) {
+                create_certinfo(ci, return_value);
+            } else {
+                RETURN_FALSE;
+            }
+            break;
+        }
+        case CURLINFO_PRIVATE:
+            if (!Z_ISUNDEF(ch->private_data)) {
+                RETURN_COPY(&ch->private_data);
+            } else {
+                RETURN_FALSE;
+            }
+            break;
+        default: {
+            int type = CURLINFO_TYPEMASK & option;
+            switch (type) {
+            case CURLINFO_STRING: {
+                char *s_code = NULL;
+
+                if (curl_easy_getinfo(ch->cp, (CURLINFO) option, &s_code) == CURLE_OK && s_code) {
+                    RETURN_STRING(s_code);
+                } else {
+                    RETURN_FALSE;
+                }
+                break;
+            }
+            case CURLINFO_LONG: {
+                zend_long code = 0;
+
+                if (curl_easy_getinfo(ch->cp, (CURLINFO) option, &code) == CURLE_OK) {
+                    RETURN_LONG(code);
+                } else {
+                    RETURN_FALSE;
+                }
+                break;
+            }
+            case CURLINFO_DOUBLE: {
+                double code = 0.0;
+
+                if (curl_easy_getinfo(ch->cp, (CURLINFO) option, &code) == CURLE_OK) {
+                    RETURN_DOUBLE(code);
+                } else {
+                    RETURN_FALSE;
+                }
+                break;
+            }
+            case CURLINFO_SLIST: {
+                struct curl_slist *slist;
+                if (curl_easy_getinfo(ch->cp, (CURLINFO) option, &slist) == CURLE_OK) {
+                    struct curl_slist *current = slist;
+                    array_init(return_value);
+                    while (current) {
+                        add_next_index_string(return_value, current->data);
+                        current = current->next;
+                    }
+                    curl_slist_free_all(slist);
+                } else {
+                    RETURN_FALSE;
+                }
+                break;
+            }
+            case CURLINFO_OFF_T: {
+                curl_off_t c_off;
+                if (curl_easy_getinfo(ch->cp, (CURLINFO) option, &c_off) == CURLE_OK) {
+                    RETURN_LONG((long) c_off);
+                } else {
+                    RETURN_FALSE;
+                }
+                break;
+            }
+            default:
+                RETURN_FALSE;
+            }
+        }
+        }
+    }
+}
+/* }}} */
+
+/* {{{ Return a string contain the last error for the current session */
+PHP_FUNCTION(swoole_native_curl_error) {
+    zval *zid;
+    php_curl *ch;
+
+    ZEND_PARSE_PARAMETERS_START(1, 1)
+    Z_PARAM_OBJECT_OF_CLASS(zid, curl_ce)
+    ZEND_PARSE_PARAMETERS_END();
+
+    if ((ch = swoole_curl_get_handle(zid)) == NULL) {
+        RETURN_FALSE;
+    }
+
+    if (ch->err.no) {
+        ch->err.str[CURL_ERROR_SIZE] = 0;
+        if (strlen(ch->err.str) > 0) {
+            RETURN_STRING(ch->err.str);
+        } else {
+            RETURN_STRING(curl_easy_strerror((CURLcode) ch->err.no));
+        }
+    } else {
+        RETURN_EMPTY_STRING();
+    }
+}
+/* }}} */
+
+/* {{{ Return an integer containing the last error number */
+PHP_FUNCTION(swoole_native_curl_errno) {
+    zval *zid;
+    php_curl *ch;
+
+    ZEND_PARSE_PARAMETERS_START(1, 1)
+    Z_PARAM_OBJECT_OF_CLASS(zid, curl_ce)
+    ZEND_PARSE_PARAMETERS_END();
+
+    if ((ch = swoole_curl_get_handle(zid)) == NULL) {
+        RETURN_FALSE;
+    }
+
+    RETURN_LONG(ch->err.no);
+}
+/* }}} */
+
+/* {{{ Close a cURL session */
+PHP_FUNCTION(swoole_native_curl_close) {
+    zval *zid;
+    php_curl *ch;
+
+    ZEND_PARSE_PARAMETERS_START(1, 1)
+    Z_PARAM_OBJECT_OF_CLASS(zid, curl_ce)
+    ZEND_PARSE_PARAMETERS_END();
+
+    if ((ch = swoole_curl_get_handle(zid)) == NULL) {
+        RETURN_FALSE;
+    }
+
+    if (ch->in_callback) {
+        zend_throw_error(NULL, "%s(): Attempt to close cURL handle from a callback", get_active_function_name());
+        RETURN_THROWS();
+    }
+}
+/* }}} */
+
+static void swoole_curl_free_obj(zend_object *object) {
+    php_curl *ch = curl_from_obj(object);
+
+#if PHP_CURL_DEBUG
+    fprintf(stderr, "DTOR CALLED, ch = %x\n", ch);
+#endif
+
+    if (!ch->cp) {
+        /* Can happen if constructor throws. */
+        zend_object_std_dtor(&ch->std);
+        return;
+    }
+
+    swoole_curl_verify_handlers(ch, /* reporterror */ false);
+
+    swoole::curl::Handle *handle = swoole::curl::get_handle(ch->cp);
+    if (handle && handle->multi) {
+        handle->multi->remove_handle(handle);
+    }
+
+    curl_easy_cleanup(ch->cp);
+
+    /* cURL destructors should be invoked only by last curl handle */
+    if (--(*ch->clone) == 0) {
+        zend_llist_clean(&ch->to_free->post);
+        zend_llist_clean(&ch->to_free->stream);
+
+        zend_hash_destroy(ch->to_free->slist);
+        efree(ch->to_free->slist);
+        efree(ch->to_free);
+        efree(ch->clone);
+        swoole::curl::destroy_handle(ch->cp);
+    }
+
+    smart_str_free(&ch->handlers.write->buf);
+    if (ZEND_FCC_INITIALIZED(ch->handlers.write->fcc)) {
+        zend_fcc_dtor(&ch->handlers.write->fcc);
+    }
+    if (ZEND_FCC_INITIALIZED(ch->handlers.write_header->fcc)) {
+        zend_fcc_dtor(&ch->handlers.write_header->fcc);
+    }
+    if (ZEND_FCC_INITIALIZED(ch->handlers.read->fcc)) {
+        zend_fcc_dtor(&ch->handlers.read->fcc);
+    }
+    zval_ptr_dtor(&ch->handlers.std_err);
+    if (ch->header.str) {
+        zend_string_release_ex(ch->header.str, 0);
+    }
+
+    zval_ptr_dtor(&ch->handlers.write_header->stream);
+    zval_ptr_dtor(&ch->handlers.write->stream);
+    zval_ptr_dtor(&ch->handlers.read->stream);
+
+    efree(ch->handlers.write);
+    efree(ch->handlers.write_header);
+    efree(ch->handlers.read);
+
+    if (ZEND_FCC_INITIALIZED(ch->handlers.progress)) {
+        zend_fcc_dtor(&ch->handlers.progress);
+    }
+    if (ZEND_FCC_INITIALIZED(ch->handlers.xferinfo)) {
+        zend_fcc_dtor(&ch->handlers.xferinfo);
+    }
+    if (ZEND_FCC_INITIALIZED(ch->handlers.fnmatch)) {
+        zend_fcc_dtor(&ch->handlers.fnmatch);
+    }
+#if LIBCURL_VERSION_NUM >= 0x075400 /* Available since 7.84.0 */
+    if (ZEND_FCC_INITIALIZED(ch->handlers.sshhostkey)) {
+        zend_fcc_dtor(&ch->handlers.sshhostkey);
+    }
+#endif
+
+    zval_ptr_dtor(&ch->postfields);
+    zval_ptr_dtor(&ch->private_data);
+
+    if (ch->share) {
+        OBJ_RELEASE(&ch->share->std);
+    }
+
+    zend_object_std_dtor(&ch->std);
+}
+/* }}} */
+
+/* {{{ return string describing error code */
+PHP_FUNCTION(swoole_native_curl_strerror) {
+    zend_long code;
+    const char *str;
+
+    ZEND_PARSE_PARAMETERS_START(1, 1)
+    Z_PARAM_LONG(code)
+    ZEND_PARSE_PARAMETERS_END();
+
+    str = curl_easy_strerror((CURLcode) code);
+    if (str) {
+        RETURN_STRING(str);
+    } else {
+        RETURN_NULL();
+    }
+}
+/* }}} */
+
+/* {{{ _php_curl_reset_handlers()
+   Reset all handlers of a given php_curl */
+static void _php_curl_reset_handlers(php_curl *ch) {
+    if (!Z_ISUNDEF(ch->handlers.write->stream)) {
+        zval_ptr_dtor(&ch->handlers.write->stream);
+        ZVAL_UNDEF(&ch->handlers.write->stream);
+    }
+    ch->handlers.write->fp = NULL;
+    ch->handlers.write->method = PHP_CURL_STDOUT;
+
+    if (!Z_ISUNDEF(ch->handlers.write_header->stream)) {
+        zval_ptr_dtor(&ch->handlers.write_header->stream);
+        ZVAL_UNDEF(&ch->handlers.write_header->stream);
+    }
+    ch->handlers.write_header->fp = NULL;
+    ch->handlers.write_header->method = PHP_CURL_IGNORE;
+
+    if (!Z_ISUNDEF(ch->handlers.read->stream)) {
+        zval_ptr_dtor(&ch->handlers.read->stream);
+        ZVAL_UNDEF(&ch->handlers.read->stream);
+    }
+    ch->handlers.read->fp = NULL;
+    ch->handlers.read->res = NULL;
+    ch->handlers.read->method = PHP_CURL_DIRECT;
+
+    if (!Z_ISUNDEF(ch->handlers.std_err)) {
+        zval_ptr_dtor(&ch->handlers.std_err);
+        ZVAL_UNDEF(&ch->handlers.std_err);
+    }
+
+    if (ZEND_FCC_INITIALIZED(ch->handlers.progress)) {
+        zend_fcc_dtor(&ch->handlers.progress);
+    }
+
+    if (ZEND_FCC_INITIALIZED(ch->handlers.xferinfo)) {
+        zend_fcc_dtor(&ch->handlers.xferinfo);
+    }
+
+    if (ZEND_FCC_INITIALIZED(ch->handlers.fnmatch)) {
+        zend_fcc_dtor(&ch->handlers.fnmatch);
+    }
+
+#if LIBCURL_VERSION_NUM >= 0x075400 /* Available since 7.84.0 */
+    if (ZEND_FCC_INITIALIZED(ch->handlers.sshhostkey)) {
+        zend_fcc_dtor(&ch->handlers.sshhostkey);
+    }
+#endif
+}
+/* }}} */
+
+/* {{{ Reset all options of a libcurl session handle */
+PHP_FUNCTION(swoole_native_curl_reset) {
+    zval *zid;
+    php_curl *ch;
+
+    ZEND_PARSE_PARAMETERS_START(1, 1)
+    Z_PARAM_OBJECT_OF_CLASS(zid, curl_ce)
+    ZEND_PARSE_PARAMETERS_END();
+
+    if ((ch = swoole_curl_get_handle(zid)) == NULL) {
+        RETURN_FALSE;
+    }
+
+    if (ch->in_callback) {
+        zend_throw_error(NULL, "%s(): Attempt to reset cURL handle from a callback", get_active_function_name());
+        RETURN_THROWS();
+    }
+
+    curl_easy_reset(ch->cp);
+    _php_curl_reset_handlers(ch);
+    _php_curl_set_default_options(ch);
+}
+/* }}} */
+
+/* {{{ URL encodes the given string */
+PHP_FUNCTION(swoole_native_curl_escape) {
+    zend_string *str;
+    char *res;
+    zval *zid;
+    php_curl *ch;
+
+    ZEND_PARSE_PARAMETERS_START(2, 2)
+    Z_PARAM_OBJECT_OF_CLASS(zid, swoole_coroutine_curl_handle_ce)
+    Z_PARAM_STR(str)
+    ZEND_PARSE_PARAMETERS_END();
+
+    if ((ch = swoole_curl_get_handle(zid)) == NULL) {
+        RETURN_FALSE;
+    }
+
+    if (ZEND_SIZE_T_INT_OVFL(ZSTR_LEN(str))) {
+        RETURN_FALSE;
+    }
+
+    if ((res = curl_easy_escape(ch->cp, ZSTR_VAL(str), ZSTR_LEN(str)))) {
+        RETVAL_STRING(res);
+        curl_free(res);
+    } else {
+        RETURN_FALSE;
+    }
+}
+/* }}} */
+
+/* {{{ URL decodes the given string */
+PHP_FUNCTION(swoole_native_curl_unescape) {
+    char *out = NULL;
+    int out_len;
+    zval *zid;
+    zend_string *str;
+    php_curl *ch;
+
+    ZEND_PARSE_PARAMETERS_START(2, 2)
+    Z_PARAM_OBJECT_OF_CLASS(zid, swoole_coroutine_curl_handle_ce)
+    Z_PARAM_STR(str)
+    ZEND_PARSE_PARAMETERS_END();
+
+    if ((ch = swoole_curl_get_handle(zid)) == NULL) {
+        RETURN_FALSE;
+    }
+
+    if (ZEND_SIZE_T_INT_OVFL(ZSTR_LEN(str))) {
+        RETURN_FALSE;
+    }
+
+    if ((out = curl_easy_unescape(ch->cp, ZSTR_VAL(str), ZSTR_LEN(str), &out_len))) {
+        RETVAL_STRINGL(out, out_len);
+        curl_free(out);
+    } else {
+        RETURN_FALSE;
+    }
+}
+/* }}} */
+
+/* {{{ pause and unpause a connection */
+PHP_FUNCTION(swoole_native_curl_pause) {
+    zend_long bitmask;
+    zval *zid;
+    php_curl *ch;
+
+    ZEND_PARSE_PARAMETERS_START(2, 2)
+    Z_PARAM_OBJECT_OF_CLASS(zid, curl_ce)
+    Z_PARAM_LONG(bitmask)
+    ZEND_PARSE_PARAMETERS_END();
+
+    if ((ch = swoole_curl_get_handle(zid)) == NULL) {
+        RETURN_FALSE;
+    }
+
+    RETURN_LONG(curl_easy_pause(ch->cp, bitmask));
+}
+/* }}} */
+
+#if LIBCURL_VERSION_NUM >= 0x073E00 /* Available since 7.62.0 */
+/* {{{ perform connection upkeep checks */
+PHP_FUNCTION(swoole_native_curl_upkeep) {
+    CURLcode error;
+    zval *zid;
+    php_curl *ch;
+
+    ZEND_PARSE_PARAMETERS_START(1, 1)
+    Z_PARAM_OBJECT_OF_CLASS(zid, curl_ce)
+    ZEND_PARSE_PARAMETERS_END();
+
+    if ((ch = swoole_curl_get_handle(zid)) == NULL) {
+        RETURN_FALSE;
+    }
+
+    error = curl_easy_upkeep(ch->cp);
+    SAVE_CURL_ERROR(ch, error);
+
+    RETURN_BOOL(error == CURLE_OK);
+}
+/*}}} */
+#endif
+#endif
diff --git a/thirdparty/php84/curl/multi.cc b/thirdparty/php84/curl/multi.cc
new file mode 100644
index 0000000000..316d715c32
--- /dev/null
+++ b/thirdparty/php84/curl/multi.cc
@@ -0,0 +1,636 @@
+/*
+   +----------------------------------------------------------------------+
+   | Copyright (c) The PHP Group                                          |
+   +----------------------------------------------------------------------+
+   | This source file is subject to version 3.01 of the PHP license,      |
+   | that is bundled with this package in the file LICENSE, and is        |
+   | available through the world-wide-web at the following url:           |
+   | https://www.php.net/license/3_01.txt                                 |
+   | If you did not receive a copy of the PHP license and are unable to   |
+   | obtain it through the world-wide-web, please send a note to          |
+   | license@php.net so we can mail you a copy immediately.               |
+   +----------------------------------------------------------------------+
+   | Author: Sterling Hughes <sterling@php.net>                           |
+   +----------------------------------------------------------------------+
+*/
+
+#include "php_swoole_cxx.h"
+#include "zend_object_handlers.h"
+
+#if defined(SW_USE_CURL) && PHP_VERSION_ID >= 80400
+
+#define ZEND_INCLUDE_FULL_WINDOWS_HEADERS
+#include "php_swoole_curl.h"
+
+using swoole::curl::Multi;
+using swoole::curl::Selector;
+
+SW_EXTERN_C_BEGIN
+#include "curl_interface.h"
+#include "curl_arginfo.h"
+
+#include <stdio.h>
+#include <string.h>
+
+#include <curl/curl.h>
+#include <curl/easy.h>
+
+#define SAVE_CURLM_ERROR(__handle, __err) (__handle)->err.no = (int) __err;
+
+void swoole_curl_multi_set_in_coroutine(php_curlm *mh, bool value) {
+    zend_update_property_bool(nullptr, &mh->std, ZEND_STRL("in_coroutine"), value);
+}
+
+bool swoole_curl_multi_is_in_coroutine(php_curlm *mh) {
+    zval rv;
+    zval *zv = zend_read_property_ex(nullptr, &mh->std, SW_ZSTR_KNOWN(SW_ZEND_STR_IN_COROUTINE), 1, &rv);
+    return zval_is_true(zv);
+}
+
+/* CurlMultiHandle class */
+zend_class_entry *swoole_coroutine_curl_multi_handle_ce;
+
+static inline php_curlm *curl_multi_from_obj(zend_object *obj) {
+    return (php_curlm *) ((char *) (obj) -XtOffsetOf(php_curlm, std));
+}
+
+#define Z_CURL_MULTI_P(zv) curl_multi_from_obj(Z_OBJ_P(zv))
+
+static void _php_curl_multi_free(php_curlm *mh);
+
+SW_EXTERN_C_END
+
+/* {{{ Returns a new cURL multi handle */
+PHP_FUNCTION(swoole_native_curl_multi_init) {
+    php_curlm *mh;
+
+    ZEND_PARSE_PARAMETERS_NONE();
+
+    object_init_ex(return_value, swoole_coroutine_curl_multi_handle_ce);
+    mh = Z_CURL_MULTI_P(return_value);
+    mh->multi = new Multi();
+    mh->multi->set_selector(new Selector());
+
+    swoole_curl_multi_set_in_coroutine(mh, true);
+    zend_llist_init(&mh->easyh, sizeof(zval), swoole_curl_multi_cleanup_list, 0);
+}
+/* }}} */
+
+/* {{{ Add a normal cURL handle to a cURL multi handle */
+PHP_FUNCTION(swoole_native_curl_multi_add_handle) {
+    zval *z_mh;
+    zval *z_ch;
+    php_curlm *mh;
+    php_curl *ch;
+    CURLMcode error = CURLM_OK;
+
+    ZEND_PARSE_PARAMETERS_START(2, 2)
+    Z_PARAM_OBJECT_OF_CLASS(z_mh, swoole_coroutine_curl_multi_handle_ce)
+    Z_PARAM_OBJECT_OF_CLASS(z_ch, swoole_coroutine_curl_handle_ce)
+    ZEND_PARSE_PARAMETERS_END();
+
+    mh = Z_CURL_MULTI_P(z_mh);
+    ch = Z_CURL_P(z_ch);
+
+    if (!(swoole_curl_multi_is_in_coroutine(mh))) {
+        swoole_fatal_error(SW_ERROR_WRONG_OPERATION,
+                           "The given object is not a valid coroutine CurlMultiHandle object");
+        RETURN_FALSE;
+    }
+
+    swoole_curl_verify_handlers(ch, /* reporterror */ true);
+    swoole_curl_cleanup_handle(ch);
+
+    Z_ADDREF_P(z_ch);
+    zend_llist_add_element(&mh->easyh, z_ch);
+
+    auto handle = swoole::curl::get_handle(ch->cp);
+    error = mh->multi->add_handle(handle);
+
+    swoole_trace_log(SW_TRACE_CO_CURL, "multi=%p, cp=%p, handle=%p, error=%d", mh->multi, ch->cp, handle, error);
+    SAVE_CURLM_ERROR(mh, error);
+    RETURN_LONG((zend_long) error);
+}
+/* }}} */
+
+void swoole_curl_multi_cleanup_list(void *data) /* {{{ */
+{
+    zval *z_ch = (zval *) data;
+
+    zval_ptr_dtor(z_ch);
+}
+/* }}} */
+
+/* Used internally as comparison routine passed to zend_list_del_element */
+static int curl_compare_objects(zval *z1, zval *z2) /* {{{ */
+{
+    return (Z_TYPE_P(z1) == Z_TYPE_P(z2) && Z_TYPE_P(z1) == IS_OBJECT && Z_OBJ_P(z1) == Z_OBJ_P(z2));
+}
+/* }}} */
+
+/* Used to find the php_curl resource for a given curl easy handle */
+static zval *_php_curl_multi_find_easy_handle(php_curlm *mh, CURL *easy) /* {{{ */
+{
+    php_curl *tmp_ch;
+    zend_llist_position pos;
+    zval *pz_ch_temp;
+
+    for (pz_ch_temp = (zval *) zend_llist_get_first_ex(&mh->easyh, &pos); pz_ch_temp;
+         pz_ch_temp = (zval *) zend_llist_get_next_ex(&mh->easyh, &pos)) {
+         tmp_ch = swoole_curl_get_handle(pz_ch_temp, false, false);
+
+         if (tmp_ch && tmp_ch->cp == easy) {
+             return pz_ch_temp;
+         }
+    }
+
+    return NULL;
+}
+/* }}} */
+
+/* {{{ Remove a multi handle from a set of cURL handles */
+PHP_FUNCTION(swoole_native_curl_multi_remove_handle) {
+    zval *z_mh;
+    zval *z_ch;
+    php_curlm *mh;
+    php_curl *ch;
+    CURLMcode error = CURLM_OK;
+
+    ZEND_PARSE_PARAMETERS_START(2, 2)
+    Z_PARAM_OBJECT_OF_CLASS(z_mh, swoole_coroutine_curl_multi_handle_ce)
+    Z_PARAM_OBJECT_OF_CLASS(z_ch, swoole_coroutine_curl_handle_ce)
+    ZEND_PARSE_PARAMETERS_END();
+
+    mh = Z_CURL_MULTI_P(z_mh);
+    if (!(swoole_curl_multi_is_in_coroutine(mh))) {
+        swoole_fatal_error(SW_ERROR_WRONG_OPERATION,
+                           "The given object is not a valid coroutine CurlMultiHandle object");
+        RETURN_FALSE;
+    }
+
+    ch = Z_CURL_P(z_ch);
+    auto handle = swoole::curl::get_handle(ch->cp);
+    if (handle && handle->multi) {
+        error = mh->multi->remove_handle(handle);
+    } else {
+        error = curl_multi_remove_handle(mh->multi, ch->cp);
+    }
+
+    swoole_trace_log(SW_TRACE_CO_CURL, "multi=%p, cp=%p, handle=%p, error=%d", mh->multi, ch->cp, handle, error);
+    SAVE_CURLM_ERROR(mh, error);
+    RETVAL_LONG((zend_long) error);
+    zend_llist_del_element(&mh->easyh, z_ch, (int (*)(void *, void *)) curl_compare_objects);
+}
+/* }}} */
+
+/* {{{ Get all the sockets associated with the cURL extension, which can then be "selected" */
+PHP_FUNCTION(swoole_native_curl_multi_select) {
+    zval *z_mh;
+    php_curlm *mh;
+    double timeout = 1.0;
+
+    ZEND_PARSE_PARAMETERS_START(1, 2)
+    Z_PARAM_OBJECT_OF_CLASS(z_mh, swoole_coroutine_curl_multi_handle_ce)
+    Z_PARAM_OPTIONAL
+    Z_PARAM_DOUBLE(timeout)
+    ZEND_PARSE_PARAMETERS_END();
+
+    mh = Z_CURL_MULTI_P(z_mh);
+    if (!(swoole_curl_multi_is_in_coroutine(mh))) {
+        swoole_fatal_error(SW_ERROR_WRONG_OPERATION,
+                           "The given object is not a valid coroutine CurlMultiHandle object");
+        RETURN_FALSE;
+    }
+
+    RETURN_LONG(mh->multi->select(mh, timeout));
+}
+/* }}} */
+
+/* {{{ Run the sub-connections of the current cURL handle */
+PHP_FUNCTION(swoole_native_curl_multi_exec) {
+    zval *z_mh;
+    zval *z_still_running;
+    php_curlm *mh;
+    int still_running;
+    CURLMcode error = CURLM_OK;
+
+    ZEND_PARSE_PARAMETERS_START(2, 2)
+    Z_PARAM_OBJECT_OF_CLASS(z_mh, swoole_coroutine_curl_multi_handle_ce)
+    Z_PARAM_ZVAL(z_still_running)
+    ZEND_PARSE_PARAMETERS_END();
+
+    mh = Z_CURL_MULTI_P(z_mh);
+    if (!(swoole_curl_multi_is_in_coroutine(mh))) {
+        swoole_fatal_error(SW_ERROR_WRONG_OPERATION,
+                           "The given object is not a valid coroutine CurlMultiHandle object");
+        RETURN_FALSE;
+    }
+
+    {
+        zend_llist_position pos;
+        php_curl *ch;
+        zval *pz_ch;
+
+        for (pz_ch = (zval *) zend_llist_get_first_ex(&mh->easyh, &pos); pz_ch;
+             pz_ch = (zval *) zend_llist_get_next_ex(&mh->easyh, &pos)) {
+            ch = Z_CURL_P(pz_ch);
+            swoole_curl_verify_handlers(ch, /* reporterror */ true);
+        }
+    }
+
+    error = mh->multi->perform();
+    still_running = mh->multi->get_running_handles();
+    ZEND_TRY_ASSIGN_REF_LONG(z_still_running, still_running);
+
+    SAVE_CURLM_ERROR(mh, error);
+    RETURN_LONG((zend_long) error);
+}
+/* }}} */
+
+/* {{{ Return the content of a cURL handle if CURLOPT_RETURNTRANSFER is set */
+PHP_FUNCTION(swoole_native_curl_multi_getcontent) {
+    zval *z_ch;
+    php_curl *ch;
+
+    ZEND_PARSE_PARAMETERS_START(1, 1)
+    Z_PARAM_OBJECT_OF_CLASS(z_ch, swoole_coroutine_curl_handle_ce)
+    ZEND_PARSE_PARAMETERS_END();
+
+    ch = Z_CURL_P(z_ch);
+
+    if (ch->handlers.write->method == PHP_CURL_RETURN) {
+        if (!ch->handlers.write->buf.s) {
+            RETURN_EMPTY_STRING();
+        }
+        smart_str_0(&ch->handlers.write->buf);
+        RETURN_STR_COPY(ch->handlers.write->buf.s);
+    }
+
+    RETURN_NULL();
+}
+/* }}} */
+
+/* {{{ Get information about the current transfers */
+PHP_FUNCTION(swoole_native_curl_multi_info_read) {
+    zval *z_mh;
+    php_curlm *mh;
+    CURLMsg *tmp_msg;
+    int queued_msgs;
+    zval *zmsgs_in_queue = NULL;
+    php_curl *ch;
+
+    ZEND_PARSE_PARAMETERS_START(1, 2)
+    Z_PARAM_OBJECT_OF_CLASS(z_mh, swoole_coroutine_curl_multi_handle_ce)
+    Z_PARAM_OPTIONAL
+    Z_PARAM_ZVAL(zmsgs_in_queue)
+    ZEND_PARSE_PARAMETERS_END();
+
+    mh = Z_CURL_MULTI_P(z_mh);
+    if (!(swoole_curl_multi_is_in_coroutine(mh))) {
+        swoole_fatal_error(SW_ERROR_WRONG_OPERATION,
+                           "The given object is not a valid coroutine CurlMultiHandle object");
+        RETURN_FALSE;
+    }
+
+    tmp_msg = curl_multi_info_read(mh->multi->get_multi_handle(), &queued_msgs);
+    if (tmp_msg == NULL) {
+        RETURN_FALSE;
+    }
+
+    if (zmsgs_in_queue) {
+        ZEND_TRY_ASSIGN_REF_LONG(zmsgs_in_queue, queued_msgs);
+    }
+
+    array_init(return_value);
+    add_assoc_long(return_value, "msg", tmp_msg->msg);
+    add_assoc_long(return_value, "result", tmp_msg->data.result);
+
+    /* find the original easy curl handle */
+    {
+        zval *pz_ch = _php_curl_multi_find_easy_handle(mh, tmp_msg->easy_handle);
+        if (pz_ch != NULL) {
+            /* we must save result to be able to read error message */
+            ch = swoole_curl_get_handle(pz_ch, false, false);
+            SAVE_CURL_ERROR(ch, tmp_msg->data.result);
+
+            Z_ADDREF_P(pz_ch);
+            add_assoc_zval(return_value, "handle", pz_ch);
+        }
+    }
+}
+/* }}} */
+
+/* {{{ Close a set of cURL handles */
+PHP_FUNCTION(swoole_native_curl_multi_close) {
+    php_curlm *mh;
+    zval *z_mh;
+
+    zend_llist_position pos;
+    zval *pz_ch;
+
+    ZEND_PARSE_PARAMETERS_START(1, 1)
+    Z_PARAM_OBJECT_OF_CLASS(z_mh, swoole_coroutine_curl_multi_handle_ce)
+    ZEND_PARSE_PARAMETERS_END();
+
+    mh = Z_CURL_MULTI_P(z_mh);
+
+    for (pz_ch = (zval *) zend_llist_get_first_ex(&mh->easyh, &pos); pz_ch;
+         pz_ch = (zval *) zend_llist_get_next_ex(&mh->easyh, &pos)) {
+        php_curl *ch = Z_CURL_P(pz_ch);
+        if (!ch) {
+            continue;
+        }
+        swoole_curl_verify_handlers(ch, 0);
+        auto handle = swoole::curl::get_handle(ch->cp);
+        if (handle) {
+            mh->multi->remove_handle(handle);
+        } else {
+            curl_multi_remove_handle(mh->multi, ch->cp);
+        }
+    }
+    zend_llist_clean(&mh->easyh);
+}
+/* }}} */
+
+/* {{{ Return an integer containing the last multi curl error number */
+PHP_FUNCTION(swoole_native_curl_multi_errno) {
+    zval *z_mh;
+    php_curlm *mh;
+
+    ZEND_PARSE_PARAMETERS_START(1, 1)
+    Z_PARAM_OBJECT_OF_CLASS(z_mh, swoole_coroutine_curl_multi_handle_ce)
+    ZEND_PARSE_PARAMETERS_END();
+
+    mh = Z_CURL_MULTI_P(z_mh);
+
+    RETURN_LONG(mh->err.no);
+}
+/* }}} */
+
+/* {{{ return string describing error code */
+PHP_FUNCTION(swoole_native_curl_multi_strerror) {
+    zend_long code;
+    const char *str;
+
+    ZEND_PARSE_PARAMETERS_START(1, 1)
+    Z_PARAM_LONG(code)
+    ZEND_PARSE_PARAMETERS_END();
+
+    str = curl_multi_strerror((CURLMcode) code);
+    if (str) {
+        RETURN_STRING(str);
+    } else {
+        RETURN_NULL();
+    }
+}
+/* }}} */
+
+static int _php_server_push_callback(
+    CURL *parent_ch, CURL *easy, size_t num_headers, struct curl_pushheaders *push_headers, void *userp) /* {{{ */
+{
+    php_curl *ch;
+    php_curl *parent;
+    php_curlm *mh = (php_curlm *) userp;
+    size_t rval = CURL_PUSH_DENY;
+    zval *pz_parent_ch = NULL;
+    zval pz_ch;
+    zval headers;
+    zval retval;
+
+    pz_parent_ch = _php_curl_multi_find_easy_handle(mh, parent_ch);
+    if (pz_parent_ch == NULL) {
+        return rval;
+    }
+
+    parent = Z_CURL_P(pz_parent_ch);
+
+    ch = swoole_curl_init_handle_into_zval(&pz_ch);
+    ch->cp = easy;
+    swoole_setup_easy_copy_handlers(ch, parent);
+
+    auto parent_handle = swoole::curl::get_handle(parent->cp);
+    if (parent_handle) {
+        auto handle = swoole::curl::create_handle(easy);
+        handle->multi = parent_handle->multi;
+    }
+
+    array_init(&headers);
+    for (size_t i = 0; i < num_headers; i++) {
+        char *header = curl_pushheader_bynum(push_headers, i);
+        add_next_index_string(&headers, header);
+    }
+
+    ZEND_ASSERT(pz_parent_ch);
+    zval call_args[3] = {*pz_parent_ch, pz_ch, headers};
+
+    zend_call_known_fcc(&mh->handlers.server_push, &retval, /* param_count */ 3, call_args, /* named_params */ NULL);
+    zval_ptr_dtor_nogc(&headers);
+
+    if (!Z_ISUNDEF(retval)) {
+        if (CURL_PUSH_DENY != zval_get_long(&retval)) {
+            rval = CURL_PUSH_OK;
+            zend_llist_add_element(&mh->easyh, &pz_ch);
+        } else {
+            /* libcurl will free this easy handle, avoid double free */
+            ch->cp = NULL;
+        }
+    }
+
+    return rval;
+}
+/* }}} */
+
+static bool _php_curl_multi_setopt(php_curlm *mh, zend_long option, zval *zvalue, zval *return_value) /* {{{ */
+{
+    CURLMcode error = CURLM_OK;
+
+    switch (option) {
+    case CURLMOPT_PIPELINING:
+    case CURLMOPT_MAXCONNECTS:
+    case CURLMOPT_CHUNK_LENGTH_PENALTY_SIZE:
+    case CURLMOPT_CONTENT_LENGTH_PENALTY_SIZE:
+    case CURLMOPT_MAX_HOST_CONNECTIONS:
+    case CURLMOPT_MAX_PIPELINE_LENGTH:
+    case CURLMOPT_MAX_TOTAL_CONNECTIONS:
+#if LIBCURL_VERSION_NUM >= 0x074300 /* Available since 7.67.0 */
+    case CURLMOPT_MAX_CONCURRENT_STREAMS:
+#endif
+    {
+        zend_long lval = zval_get_long(zvalue);
+
+        if (option == CURLMOPT_PIPELINING && (lval & 1)) {
+#if LIBCURL_VERSION_NUM >= 0x073e00 /* Available since 7.62.0 */
+            php_error_docref(NULL, E_WARNING, "CURLPIPE_HTTP1 is no longer supported");
+#else
+            php_error_docref(NULL, E_DEPRECATED, "CURLPIPE_HTTP1 is deprecated");
+#endif
+        }
+        error = curl_multi_setopt(mh->multi, (CURLMoption) option, lval);
+        break;
+    }
+    case CURLMOPT_PUSHFUNCTION: {
+        /* See php_curl_set_callable_handler */
+        if (ZEND_FCC_INITIALIZED(mh->handlers.server_push)) {
+            zend_fcc_dtor(&mh->handlers.server_push);
+        }
+
+        char *error_str = NULL;
+        if (UNEXPECTED(!zend_is_callable_ex(zvalue,
+                                            /* object */ NULL,
+                                            /* check_flags */ 0,
+                                            /* callable_name */ NULL,
+                                            &mh->handlers.server_push,
+                                            /* error */ &error_str))) {
+            if (!EG(exception)) {
+                zend_argument_type_error(2, "must be a valid callback for option CURLMOPT_PUSHFUNCTION, %s", error_str);
+            }
+            efree(error_str);
+            return false;
+        }
+        zend_fcc_addref(&mh->handlers.server_push);
+
+        error = curl_multi_setopt(mh->multi, CURLMOPT_PUSHFUNCTION, _php_server_push_callback);
+        if (error != CURLM_OK) {
+            return false;
+        }
+        error = curl_multi_setopt(mh->multi, CURLMOPT_PUSHDATA, mh);
+        break;
+    }
+    default:
+        zend_argument_value_error(2, "is not a valid cURL multi option");
+        error = CURLM_UNKNOWN_OPTION;
+        break;
+    }
+
+    SAVE_CURLM_ERROR(mh, error);
+
+    return error == CURLM_OK;
+}
+/* }}} */
+
+/* {{{ Set an option for the curl multi handle */
+PHP_FUNCTION(swoole_native_curl_multi_setopt) {
+    zval *z_mh, *zvalue;
+    zend_long options;
+    php_curlm *mh;
+
+    ZEND_PARSE_PARAMETERS_START(3, 3)
+    Z_PARAM_OBJECT_OF_CLASS(z_mh, swoole_coroutine_curl_multi_handle_ce)
+    Z_PARAM_LONG(options)
+    Z_PARAM_ZVAL(zvalue)
+    ZEND_PARSE_PARAMETERS_END();
+
+    mh = Z_CURL_MULTI_P(z_mh);
+    if (!(swoole_curl_multi_is_in_coroutine(mh))) {
+        swoole_fatal_error(SW_ERROR_WRONG_OPERATION,
+                           "The given object is not a valid coroutine CurlMultiHandle object");
+        RETURN_FALSE;
+    }
+    if (_php_curl_multi_setopt(mh, (CURLMoption) options, zvalue, return_value)) {
+        RETURN_TRUE;
+    } else {
+        RETURN_FALSE;
+    }
+}
+/* }}} */
+
+/* CurlMultiHandle class */
+
+static zend_object_handlers swoole_coroutine_curl_multi_handle_handlers;
+
+static zend_object *swoole_curl_multi_create_object(zend_class_entry *class_type) {
+    php_curlm *intern = (php_curlm *) zend_object_alloc(sizeof(php_curlm), class_type);
+
+    zend_object_std_init(&intern->std, class_type);
+    object_properties_init(&intern->std, class_type);
+    intern->std.handlers = &swoole_coroutine_curl_multi_handle_handlers;
+
+    return &intern->std;
+}
+
+static zend_function *swoole_curl_multi_get_constructor(zend_object *object) {
+    zend_throw_error(NULL, "Cannot directly construct CurlMultiHandle, use curl_multi_init() instead");
+    return NULL;
+}
+
+static void swoole_curl_multi_free_obj(zend_object *object) {
+    php_curlm *mh = curl_multi_from_obj(object);
+
+    if (!mh->multi) {
+        /* Can happen if constructor throws. */
+        zend_object_std_dtor(&mh->std);
+        return;
+    }
+
+    _php_curl_multi_free(mh);
+    zend_object_std_dtor(&mh->std);
+}
+
+static HashTable *swoole_curl_multi_get_gc(zend_object *object, zval **table, int *n) {
+    php_curlm *curl_multi = curl_multi_from_obj(object);
+
+    zend_get_gc_buffer *gc_buffer = zend_get_gc_buffer_create();
+
+    if (ZEND_FCC_INITIALIZED(curl_multi->handlers.server_push)) {
+        zend_get_gc_buffer_add_fcc(gc_buffer, &curl_multi->handlers.server_push);
+    }
+
+    zend_llist_position pos;
+    for (zval *pz_ch = (zval *) zend_llist_get_first_ex(&curl_multi->easyh, &pos); pz_ch;
+         pz_ch = (zval *) zend_llist_get_next_ex(&curl_multi->easyh, &pos)) {
+        zend_get_gc_buffer_add_zval(gc_buffer, pz_ch);
+    }
+
+    zend_get_gc_buffer_use(gc_buffer, table, n);
+
+    return zend_std_get_properties(object);
+}
+
+void curl_multi_register_class(const zend_function_entry *method_entries) {
+    swoole_coroutine_curl_multi_handle_ce = curl_multi_ce;
+    swoole_coroutine_curl_multi_handle_ce->create_object = swoole_curl_multi_create_object;
+
+    memcpy(&swoole_coroutine_curl_multi_handle_handlers, &std_object_handlers, sizeof(zend_object_handlers));
+    swoole_coroutine_curl_multi_handle_handlers.offset = XtOffsetOf(php_curlm, std);
+    swoole_coroutine_curl_multi_handle_handlers.free_obj = swoole_curl_multi_free_obj;
+    swoole_coroutine_curl_multi_handle_handlers.get_gc = swoole_curl_multi_get_gc;
+    swoole_coroutine_curl_multi_handle_handlers.get_constructor = swoole_curl_multi_get_constructor;
+    swoole_coroutine_curl_multi_handle_handlers.clone_obj = NULL;
+    swoole_coroutine_curl_multi_handle_handlers.cast_object = swoole_curl_cast_object;
+    swoole_coroutine_curl_multi_handle_handlers.compare = [](zval *o1, zval *o2) { return ZEND_UNCOMPARABLE; };
+
+    zend_declare_property_bool(swoole_coroutine_curl_multi_handle_ce, ZEND_STRL("in_coroutine"), 0, ZEND_ACC_PUBLIC);
+}
+
+static void _php_curl_multi_free(php_curlm *mh) {
+    bool is_in_coroutine = swoole_curl_multi_is_in_coroutine(mh);
+    for (zend_llist_element *element = mh->easyh.head; element; element = element->next) {
+        zval *z_ch = (zval *) element->data;
+        php_curl *ch;
+        if (OBJ_FLAGS(Z_OBJ_P(z_ch)) & IS_OBJ_FREE_CALLED) {
+            continue;
+        }
+        if ((ch = swoole_curl_get_handle(z_ch, true, false))) {
+            swoole_curl_verify_handlers(ch, 0);
+            auto handle = swoole::curl::get_handle(ch->cp);
+            if (is_in_coroutine && handle) {
+                mh->multi->remove_handle(handle);
+            } else {
+                curl_multi_remove_handle(mh->multi, ch->cp);
+            }
+        }
+    }
+    if (mh->multi) {
+        if (is_in_coroutine) {
+            delete mh->multi;
+        } else {
+            curl_multi_cleanup(mh->multi);
+        }
+        mh->multi = nullptr;
+    }
+    zend_llist_clean(&mh->easyh);
+    if (ZEND_FCC_INITIALIZED(mh->handlers.server_push)) {
+        zend_fcc_dtor(&mh->handlers.server_push);
+    }
+}
+#endif
diff --git a/thirdparty/php84/curl/php_curl.h b/thirdparty/php84/curl/php_curl.h
new file mode 100644
index 0000000000..e2b551bad9
--- /dev/null
+++ b/thirdparty/php84/curl/php_curl.h
@@ -0,0 +1,49 @@
+/*
+   +----------------------------------------------------------------------+
+   | Copyright (c) The PHP Group                                          |
+   +----------------------------------------------------------------------+
+   | This source file is subject to version 3.01 of the PHP license,      |
+   | that is bundled with this package in the file LICENSE, and is        |
+   | available through the world-wide-web at the following url:           |
+   | https://www.php.net/license/3_01.txt                                 |
+   | If you did not receive a copy of the PHP license and are unable to   |
+   | obtain it through the world-wide-web, please send a note to          |
+   | license@php.net so we can mail you a copy immediately.               |
+   +----------------------------------------------------------------------+
+   | Author: Sterling Hughes <sterling@php.net>                           |
+   |         Wez Furlong <wez@thebrainroom.com>                           |
+   +----------------------------------------------------------------------+
+*/
+
+#if defined(SW_USE_CURL) && PHP_VERSION_ID >= 80400
+
+#ifndef _PHP_CURL_H
+#define _PHP_CURL_H
+
+#include "php.h"
+#include "zend_smart_str.h"
+
+#define PHP_CURL_DEBUG 0
+
+#ifdef PHP_WIN32
+# ifdef PHP_CURL_EXPORTS
+#  define PHP_CURL_API __declspec(dllexport)
+# else
+#  define PHP_CURL_API __declspec(dllimport)
+# endif
+#elif defined(__GNUC__) && __GNUC__ >= 4
+# define PHP_CURL_API __attribute__ ((visibility("default")))
+#else
+# define PHP_CURL_API
+#endif
+
+PHP_CURL_API extern zend_class_entry *curl_ce;
+PHP_CURL_API extern zend_class_entry *curl_share_ce;
+PHP_CURL_API extern zend_class_entry *curl_multi_ce;
+PHP_CURL_API extern zend_class_entry *swoole_coroutine_curl_handle_ce;
+PHP_CURL_API extern zend_class_entry *swoole_coroutine_curl_multi_handle_ce;
+PHP_CURL_API extern zend_class_entry *curl_CURLFile_class;
+PHP_CURL_API extern zend_class_entry *curl_CURLStringFile_class;
+
+#endif  /* _PHP_CURL_H */
+#endif
--- a/ext-src/swoole_coroutine.cc.bak	2024-10-13 03:29:53
+++ b/ext-src/swoole_coroutine.cc	2024-10-13 03:30:59
@@ -990,8 +990,10 @@
 
 void php_swoole_coroutine_rinit() {
     if (SWOOLE_G(cli)) {
+#if PHP_VERSION_ID < 80400
         ori_exit_handler = zend_get_user_opcode_handler(ZEND_EXIT);
         zend_set_user_opcode_handler(ZEND_EXIT, coro_exit_handler);
+#endif
 
         ori_begin_silence_handler = zend_get_user_opcode_handler(ZEND_BEGIN_SILENCE);
         zend_set_user_opcode_handler(ZEND_BEGIN_SILENCE, coro_begin_silence_handler);
